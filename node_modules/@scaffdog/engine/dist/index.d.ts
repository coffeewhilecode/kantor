import { SourceRange, Context, Helper, HelperMap, TagPair } from '@scaffdog/types';

type Node = Comment | NullLiteral | UndefinedLiteral | BooleanLiteral | NumericLiteral | StringLiteral | Identifier | MemberExpression | UpdateExpression | UnaryExpression | BinaryExpression | LogicalExpression | ConditionalExpression | CallExpression | ParenthesizedExpression | Tag | EndStatement | ContinueStatement | BreakStatement | ExpressionStatement | VariableStatement | IfStatement | ForStatement | TagTemplate | RawTemplate | Program;
type BaseNode = {
    type: string;
    range: SourceRange;
};
type NodeProps<T extends BaseNode> = Omit<T, 'type' | 'range'>;
/**
 * Base
 */
type Comment = Omit<BaseNode, 'type'> & {
    type: 'Comment';
    body: string;
};
declare const createComment: (body: string, range: SourceRange) => Comment;
declare const isComment: (node: unknown) => node is Comment;
type WithComment<T> = T & {
    leadingComments: readonly Comment[];
    trailingComments: readonly Comment[];
};
type NullLiteral = Omit<BaseNode, 'type'> & WithComment<{
    type: 'NullLiteral';
}>;
declare const createNullLiteral: (range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => NullLiteral;
declare const isNullLiteral: (node: unknown) => node is NullLiteral;
type UndefinedLiteral = Omit<BaseNode, 'type'> & WithComment<{
    type: 'UndefinedLiteral';
}>;
declare const createUndefinedLiteral: (range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => UndefinedLiteral;
declare const isUndefinedLiteral: (node: unknown) => node is UndefinedLiteral;
type BooleanLiteral = Omit<BaseNode, 'type'> & WithComment<{
    type: 'BooleanLiteral';
    value: boolean;
}>;
declare const createBooleanLiteral: (value: boolean, range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => BooleanLiteral;
declare const isBooleanLiteral: (node: unknown) => node is BooleanLiteral;
type NumericLiteral = Omit<BaseNode, 'type'> & WithComment<{
    type: 'NumericLiteral';
    value: number;
}>;
declare const createNumericLiteral: (value: number, range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => NumericLiteral;
declare const isNumericLiteral: (node: unknown) => node is NumericLiteral;
type StringLiteral = Omit<BaseNode, 'type'> & WithComment<{
    type: 'StringLiteral';
    value: string;
    quote: string;
}>;
declare const createStringLiteral: (value: string, quote: string, range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => StringLiteral;
declare const isStringLiteral: (node: unknown) => node is StringLiteral;
type LiteralKind = NullLiteral | UndefinedLiteral | BooleanLiteral | NumericLiteral | StringLiteral;
declare const isLiteral: (node: unknown) => node is LiteralKind;
type Identifier = Omit<BaseNode, 'type'> & WithComment<{
    type: 'Identifier';
    name: string;
}>;
declare const createIdentifier: (name: string, range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => Identifier;
declare const isIdentifier: (node: unknown) => node is Identifier;
/**
 * Expressions
 */
type StaticMemberAccessorKind = Identifier | NumericLiteral;
type MemberExpressionObjectKind = PrimaryExpressionKind | MemberExpression | CallExpression;
type MemberExpressionPropertyKind = ExpressionKind | PrimaryExpressionKind;
type MemberExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'MemberExpression';
    object: MemberExpressionObjectKind;
    property: MemberExpressionPropertyKind;
    computed: boolean;
}>;
declare const createMemberExpression: (object: MemberExpressionObjectKind, property: MemberExpressionPropertyKind, computed: boolean, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => MemberExpression;
declare const isMemberExpression: (node: unknown) => node is MemberExpression;
type UpdateExpressionOperator = '++' | '--';
type UpdateExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'UpdateExpression';
    argument: LeftHandSideExpressionKind;
    operator: UpdateExpressionOperator;
    prefix: boolean;
}>;
declare const createUpdateExpression: (argument: LeftHandSideExpressionKind, operator: UpdateExpressionOperator, prefix: boolean, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => UpdateExpression;
declare const isUpdateExpression: (node: unknown) => node is UpdateExpression;
type UnaryExpressionOperator = '+' | '-' | '~' | '!';
type UnaryExpressionArgumentKind = LeftHandSideExpressionKind | UpdateExpression | UnaryExpression;
type UnaryExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'UnaryExpression';
    operator: UnaryExpressionOperator;
    argument: UnaryExpressionArgumentKind;
}>;
declare const createUnaryExpression: (operator: UnaryExpressionOperator, argument: UnaryExpressionArgumentKind, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => UnaryExpression;
declare const isUnaryExpression: (node: unknown) => node is UnaryExpression;
type BinaryExpressionOperator = '+' | '-' | '*' | '/' | '%' | '<' | '>' | '<=' | '>=' | '==' | '!=';
type BinaryExpressionOperandKind = LeftHandSideExpressionKind | UnaryExpression | UpdateExpression | BinaryExpression;
type BinaryExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'BinaryExpression';
    left: BinaryExpressionOperandKind;
    operator: BinaryExpressionOperator;
    right: BinaryExpressionOperandKind;
}>;
declare const createBinaryExpression: (left: BinaryExpressionOperandKind, operator: BinaryExpressionOperator, right: BinaryExpressionOperandKind, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => BinaryExpression;
declare const isBinaryExpression: (node: unknown) => node is BinaryExpression;
type LogicalExpressionOperator = '&&' | '||';
type LogicalExpressionOperandKind = BinaryExpressionOperandKind | LogicalExpression;
type LogicalExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'LogicalExpression';
    left: LogicalExpressionOperandKind;
    operator: LogicalExpressionOperator;
    right: LogicalExpressionOperandKind;
}>;
declare const createLogicalExpression: (left: LogicalExpressionOperandKind, operator: LogicalExpressionOperator, right: LogicalExpressionOperandKind, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => LogicalExpression;
declare const isLogicalExpression: (node: unknown) => node is LogicalExpression;
type ConditionalExpressionTestKind = LogicalExpressionOperandKind;
type ConditionalExpressionBodyKind = ConditionalExpressionTestKind | ConditionalExpression;
type ConditionalExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'ConditionalExpression';
    test: LogicalExpressionOperandKind;
    consequent: ConditionalExpressionBodyKind;
    alternate: ConditionalExpressionBodyKind;
}>;
declare const createConditionalExpression: (test: LogicalExpressionOperandKind, consequent: ConditionalExpressionBodyKind, alternate: ConditionalExpressionBodyKind, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => ConditionalExpression;
declare const isConditionalExpression: (node: unknown) => node is ConditionalExpression;
type ArgumentKind = ConditionalExpression | LogicalExpressionOperandKind | CallExpression;
type ArgumentList = ArgumentKind[];
type CallExpressionCalleeKind = LeftHandSideExpressionKind | ConditionalExpression | LogicalExpressionOperandKind;
type CallExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'CallExpression';
    callee: CallExpressionCalleeKind;
    args: ArgumentList;
    piped: boolean;
    innerComments: readonly Comment[];
}>;
declare const createCallExpression: (callee: CallExpressionCalleeKind, args: ArgumentList, piped: boolean, range: SourceRange, leadingComments?: readonly Comment[], innerComments?: readonly Comment[], trailingComments?: readonly Comment[]) => CallExpression;
declare const isCallExpression: (node: unknown) => node is CallExpression;
type PipeArgumentKind = UnaryExpressionArgumentKind | UnaryExpression;
type PipeArgumentList = PipeArgumentKind[];
type PipeHeadKind = LogicalExpressionOperandKind | ConditionalExpression;
type PipeBodyKind = PrimaryExpressionKind | MemberExpression;
type ParenthesizedExpression = Omit<BaseNode, 'type'> & WithComment<{
    type: 'ParenthesizedExpression';
    expression: ExpressionKind;
}>;
declare const createParenthesizedExpression: (expression: ExpressionKind, range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => ParenthesizedExpression;
declare const isParenthesizedExpression: (node: unknown) => node is ParenthesizedExpression;
type PrimaryExpressionKind = Identifier | LiteralKind | ParenthesizedExpression;
declare const isPrimaryExpression: (node: unknown) => node is PrimaryExpressionKind;
type LeftHandSideExpressionKind = PrimaryExpressionKind | MemberExpression | CallExpression;
declare const isLeftHandSideExpression: (node: unknown) => node is LeftHandSideExpressionKind;
type ExpressionKind = PrimaryExpressionKind | MemberExpression | UpdateExpression | UnaryExpression | BinaryExpression | LogicalExpression | ConditionalExpression | CallExpression;
declare const isExpression: (node: unknown) => node is ExpressionKind;
/**
 * Statements
 */
type StatementKind = ContinueStatement | BreakStatement | VariableStatement | ExpressionStatement | IfStatement | ForStatement;
type TagVariant = 'open' | 'close';
type Tag = Omit<BaseNode, 'type'> & WithComment<{
    type: 'Tag';
    variant: TagVariant;
    delimiter: string;
    strip: boolean;
    range: SourceRange;
}>;
declare const createTag: (variant: TagVariant, delimiter: string, strip: boolean, range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => Tag;
declare const isTag: (node: unknown) => node is Tag;
type EndStatement = Omit<BaseNode, 'type'> & WithComment<{
    type: 'EndStatement';
}>;
declare const createEndStatement: (range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => EndStatement;
declare const isEndStatement: (node: unknown) => node is EndStatement;
type ContinueStatement = Omit<BaseNode, 'type'> & WithComment<{
    type: 'ContinueStatement';
}>;
declare const createContinueStatement: (range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => ContinueStatement;
declare const isContinueStatement: (node: unknown) => node is ContinueStatement;
type BreakStatement = Omit<BaseNode, 'type'> & WithComment<{
    type: 'BreakStatement';
}>;
declare const createBreakStatement: (range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => BreakStatement;
declare const isBreakStatement: (node: unknown) => node is BreakStatement;
type ExpressionStatement = Omit<BaseNode, 'type'> & WithComment<{
    type: 'ExpressionStatement';
    expression: ExpressionKind;
}>;
declare const createExpressionStatement: (expression: ExpressionKind, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => ExpressionStatement;
declare const isExpressionStatement: (node: unknown) => node is ExpressionStatement;
type VariableStatement = Omit<BaseNode, 'type'> & WithComment<{
    type: 'VariableStatement';
    left: Identifier;
    right: ExpressionKind;
}>;
declare const createVariableStatement: (left: Identifier, right: ExpressionKind, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => VariableStatement;
declare const isVariableStatement: (node: unknown) => node is VariableStatement;
type IfStatement = Omit<BaseNode, 'type'> & WithComment<{
    type: 'IfStatement';
    test: ExpressionKind;
    consequent: Template;
    alternate: IfStatement | Template | null;
    tags: {
        ifClose: Tag;
        elseOpen: Tag | null;
        elseClose: Tag | null;
        endOpen: Tag | null;
    };
}>;
declare const createIfStatement: (test: ExpressionKind, consequent: Template, alternate: IfStatement | Template | null, tags: IfStatement['tags'], range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => IfStatement;
declare const isIfStatement: (node: unknown) => node is IfStatement;
type ForStatement = Omit<BaseNode, 'type'> & WithComment<{
    type: 'ForStatement';
    value: Identifier;
    index: Identifier | null;
    right: ExpressionKind;
    body: Template;
    tags: {
        close: Tag;
        open: Tag;
    };
}>;
declare const createForStatement: (value: Identifier, index: Identifier | null, right: ExpressionKind, body: Template, tags: ForStatement['tags'], range: SourceRange, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => ForStatement;
declare const isForStatement: (node: unknown) => node is ForStatement;
/**
 * Templates
 */
type TemplateElementKind = TagTemplate | RawTemplate;
type Template = TemplateElementKind[];
type TagTemplate = Omit<BaseNode, 'type'> & WithComment<{
    type: 'TagTemplate';
    open: Tag;
    body: StatementKind | null;
    close: Tag;
}>;
declare const createTagTemplate: (open: Tag, body: StatementKind | null, close: Tag, leadingComments?: readonly Comment[], trailingComments?: readonly Comment[]) => TagTemplate;
declare const isTagTemplate: (node: unknown) => node is TagTemplate;
type RawTemplate = Omit<BaseNode, 'type'> & {
    type: 'RawTemplate';
    body: string;
    range: SourceRange;
};
declare const createRawTemplate: (body: string, range: SourceRange) => RawTemplate;
declare const isRawTemplate: (node: unknown) => node is RawTemplate;
/**
 * Program
 */
type Program = Omit<BaseNode, 'type'> & {
    type: 'Program';
    body: Template;
    source: string;
};
declare const createProgram: (body: Template, source: string) => Program;
declare const isProgram: (node: unknown) => node is Program;

declare const compile: (ast: Program, context: Context) => string;

declare const extendContext: (context: Context, partial: Partial<Context>) => Context;
declare const createContext: (partial: Partial<Context>) => Context;

declare const format: (ast: Program) => string;

type CreateHelperOptions = {
    disableAutoLoop: boolean;
};
declare const createHelper: <T extends any[]>(fn: Helper<T>, options?: Partial<CreateHelperOptions>) => Helper<T>;
declare const defineHelper: <T extends any[]>(helpers: HelperMap, name: string, fn: Helper<T>, options?: Partial<CreateHelperOptions>) => void;

type ProgramParser = (input: string) => Program;
type ParseOptions = {
    tags: TagPair;
};
declare const parse: (source: string, options?: Partial<ParseOptions>) => Program;

declare const render: (source: string, context: Context) => string;

export { ArgumentKind, ArgumentList, BaseNode, BinaryExpression, BinaryExpressionOperandKind, BinaryExpressionOperator, BooleanLiteral, BreakStatement, CallExpression, CallExpressionCalleeKind, Comment, ConditionalExpression, ConditionalExpressionBodyKind, ConditionalExpressionTestKind, ContinueStatement, CreateHelperOptions, EndStatement, ExpressionKind, ExpressionStatement, ForStatement, Identifier, IfStatement, LeftHandSideExpressionKind, LiteralKind, LogicalExpression, LogicalExpressionOperandKind, LogicalExpressionOperator, MemberExpression, MemberExpressionObjectKind, MemberExpressionPropertyKind, Node, NodeProps, NullLiteral, NumericLiteral, ParenthesizedExpression, ParseOptions, PipeArgumentKind, PipeArgumentList, PipeBodyKind, PipeHeadKind, PrimaryExpressionKind, Program, ProgramParser, RawTemplate, StatementKind, StaticMemberAccessorKind, StringLiteral, Tag, TagTemplate, TagVariant, Template, TemplateElementKind, UnaryExpression, UnaryExpressionArgumentKind, UnaryExpressionOperator, UndefinedLiteral, UpdateExpression, UpdateExpressionOperator, VariableStatement, WithComment, compile, createBinaryExpression, createBooleanLiteral, createBreakStatement, createCallExpression, createComment, createConditionalExpression, createContext, createContinueStatement, createEndStatement, createExpressionStatement, createForStatement, createHelper, createIdentifier, createIfStatement, createLogicalExpression, createMemberExpression, createNullLiteral, createNumericLiteral, createParenthesizedExpression, createProgram, createRawTemplate, createStringLiteral, createTag, createTagTemplate, createUnaryExpression, createUndefinedLiteral, createUpdateExpression, createVariableStatement, defineHelper, extendContext, format, isBinaryExpression, isBooleanLiteral, isBreakStatement, isCallExpression, isComment, isConditionalExpression, isContinueStatement, isEndStatement, isExpression, isExpressionStatement, isForStatement, isIdentifier, isIfStatement, isLeftHandSideExpression, isLiteral, isLogicalExpression, isMemberExpression, isNullLiteral, isNumericLiteral, isParenthesizedExpression, isPrimaryExpression, isProgram, isRawTemplate, isStringLiteral, isTag, isTagTemplate, isUnaryExpression, isUndefinedLiteral, isUpdateExpression, isVariableStatement, parse, render };
