import isPlainObject from 'is-plain-obj';
import { error as error$1 } from '@scaffdog/error';
import * as cc from 'change-case';
import plur from 'plur';
import dayjs from 'dayjs';

const isNonNullish = (v) => {
  return v != null;
};
const isBoolean = (v) => typeof v === "boolean";
const isString = (v) => typeof v === "string";
const isNumber = (v) => typeof v === "number";
const isObject = (v) => isPlainObject(v);
const isArray = (v) => Array.isArray(v);
const isFunction = (v) => typeof v === "function";
const typeOf = (v) => {
  if (v === null) {
    return "null";
  } else if (v === void 0) {
    return "undefined";
  }
  if (isObject(v)) {
    return "object";
  }
  switch (typeof v) {
    case "number":
    case "bigint":
      return "number";
    case "string":
      return "string";
    case "boolean":
      return "boolean";
  }
  return "object";
};

const isNodeLike = (node) => {
  if (!isObject(node)) {
    return false;
  }
  return typeof node.type === "string";
};
const nodeGuard = (type) => (node) => {
  return isNodeLike(node) && node.type === type;
};
const composeGuard = (list) => (node) => list.some((fn) => fn(node));
const createComment = (body, range) => ({
  type: "Comment",
  body,
  range
});
const isComment = nodeGuard("Comment");
const createNullLiteral = (range, leadingComments = [], trailingComments = []) => ({
  type: "NullLiteral",
  range,
  leadingComments,
  trailingComments
});
const isNullLiteral = nodeGuard("NullLiteral");
const createUndefinedLiteral = (range, leadingComments = [], trailingComments = []) => ({
  type: "UndefinedLiteral",
  range,
  leadingComments,
  trailingComments
});
const isUndefinedLiteral = nodeGuard("UndefinedLiteral");
const createBooleanLiteral = (value, range, leadingComments = [], trailingComments = []) => ({
  type: "BooleanLiteral",
  value,
  range,
  leadingComments,
  trailingComments
});
const isBooleanLiteral = nodeGuard("BooleanLiteral");
const createNumericLiteral = (value, range, leadingComments = [], trailingComments = []) => ({
  type: "NumericLiteral",
  value,
  range,
  leadingComments,
  trailingComments
});
const isNumericLiteral = nodeGuard("NumericLiteral");
const createStringLiteral = (value, quote, range, leadingComments = [], trailingComments = []) => ({
  type: "StringLiteral",
  value,
  quote,
  range,
  leadingComments,
  trailingComments
});
const isStringLiteral = nodeGuard("StringLiteral");
const isLiteral = composeGuard([
  isNullLiteral,
  isUndefinedLiteral,
  isBooleanLiteral,
  isNumericLiteral,
  isStringLiteral
]);
const createIdentifier = (name, range, leadingComments = [], trailingComments = []) => ({
  type: "Identifier",
  name,
  range,
  leadingComments,
  trailingComments
});
const isIdentifier = nodeGuard("Identifier");
const createMemberExpression = (object, property, computed, leadingComments = [], trailingComments = []) => ({
  type: "MemberExpression",
  object,
  property,
  computed,
  range: [object.range[0], property?.range[1] ?? object.range[0]],
  leadingComments,
  trailingComments
});
const isMemberExpression = nodeGuard("MemberExpression");
const createUpdateExpression = (argument, operator, prefix, leadingComments = [], trailingComments = []) => ({
  type: "UpdateExpression",
  argument,
  operator,
  prefix,
  range: [
    argument.range[0] + (prefix ? -2 : 0),
    argument.range[1] + (prefix ? 0 : 2)
  ],
  leadingComments,
  trailingComments
});
const isUpdateExpression = nodeGuard("UpdateExpression");
const createUnaryExpression = (operator, argument, leadingComments = [], trailingComments = []) => ({
  type: "UnaryExpression",
  operator,
  argument,
  range: [argument.range[0] - 1, argument.range[1]],
  leadingComments,
  trailingComments
});
const isUnaryExpression = nodeGuard("UnaryExpression");
const createBinaryExpression = (left, operator, right, leadingComments = [], trailingComments = []) => ({
  type: "BinaryExpression",
  left,
  operator,
  right,
  range: [left.range[0], right.range[1]],
  leadingComments,
  trailingComments
});
const isBinaryExpression = nodeGuard("BinaryExpression");
const createLogicalExpression = (left, operator, right, leadingComments = [], trailingComments = []) => ({
  type: "LogicalExpression",
  left,
  operator,
  right,
  range: [left.range[0], right.range[1]],
  leadingComments,
  trailingComments
});
const isLogicalExpression = nodeGuard("LogicalExpression");
const createConditionalExpression = (test, consequent, alternate, leadingComments = [], trailingComments = []) => ({
  type: "ConditionalExpression",
  test,
  consequent,
  alternate,
  range: [test.range[0], alternate.range[1]],
  leadingComments,
  trailingComments
});
const isConditionalExpression = nodeGuard("ConditionalExpression");
const createCallExpression = (callee, args, piped, range, leadingComments = [], innerComments = [], trailingComments = []) => ({
  type: "CallExpression",
  callee,
  args,
  piped,
  range,
  leadingComments,
  innerComments,
  trailingComments
});
const isCallExpression = nodeGuard("CallExpression");
const createParenthesizedExpression = (expression, range, leadingComments = [], trailingComments = []) => ({
  type: "ParenthesizedExpression",
  expression,
  range,
  leadingComments,
  trailingComments
});
const isParenthesizedExpression = nodeGuard("ParenthesizedExpression");
const isPrimaryExpression = composeGuard([
  isIdentifier,
  isLiteral,
  isParenthesizedExpression
]);
const isLeftHandSideExpression = composeGuard([
  isPrimaryExpression,
  isMemberExpression,
  isCallExpression
]);
const isExpression = composeGuard([
  isPrimaryExpression,
  isCallExpression,
  isMemberExpression,
  isUpdateExpression,
  isUnaryExpression,
  isBinaryExpression,
  isLogicalExpression,
  isConditionalExpression,
  isCallExpression
]);
const createTag = (variant, delimiter, strip, range, leadingComments = [], trailingComments = []) => ({
  type: "Tag",
  variant,
  delimiter,
  strip,
  range,
  leadingComments,
  trailingComments
});
const isTag = nodeGuard("Tag");
const createEndStatement = (range, leadingComments = [], trailingComments = []) => ({
  type: "EndStatement",
  range,
  leadingComments,
  trailingComments
});
const isEndStatement = nodeGuard("EndStatement");
const createContinueStatement = (range, leadingComments = [], trailingComments = []) => ({
  type: "ContinueStatement",
  range,
  leadingComments,
  trailingComments
});
const isContinueStatement = nodeGuard("ContinueStatement");
const createBreakStatement = (range, leadingComments = [], trailingComments = []) => ({
  type: "BreakStatement",
  range,
  leadingComments,
  trailingComments
});
const isBreakStatement = nodeGuard("BreakStatement");
const createExpressionStatement = (expression, leadingComments = [], trailingComments = []) => ({
  type: "ExpressionStatement",
  expression,
  range: [...expression.range],
  leadingComments,
  trailingComments
});
const isExpressionStatement = nodeGuard("ExpressionStatement");
const createVariableStatement = (left, right, leadingComments = [], trailingComments = []) => ({
  type: "VariableStatement",
  left,
  right,
  range: [left.range[0], right.range[1]],
  leadingComments,
  trailingComments
});
const isVariableStatement = nodeGuard("VariableStatement");
const createIfStatement = (test, consequent, alternate, tags, range, leadingComments = [], trailingComments = []) => ({
  type: "IfStatement",
  test,
  consequent,
  alternate,
  tags,
  range,
  leadingComments,
  trailingComments
});
const isIfStatement = nodeGuard("IfStatement");
const createForStatement = (value, index, right, body, tags, range, leadingComments = [], trailingComments = []) => ({
  type: "ForStatement",
  value,
  index,
  right,
  body,
  tags,
  range,
  leadingComments,
  trailingComments
});
const isForStatement = nodeGuard("ForStatement");
const createTagTemplate = (open, body, close, leadingComments = [], trailingComments = []) => ({
  type: "TagTemplate",
  open,
  body,
  close,
  range: [open.range[0], close.range[1]],
  leadingComments,
  trailingComments
});
const isTagTemplate = nodeGuard("TagTemplate");
const createRawTemplate = (body, range) => ({
  type: "RawTemplate",
  body,
  range
});
const isRawTemplate = nodeGuard("RawTemplate");
const createProgram = (body, source) => ({
  type: "Program",
  body,
  source,
  range: [body[0]?.range[0] ?? 0, body[body.length - 1]?.range[0] ?? 0]
});
const isProgram = nodeGuard("Program");

class IterateState {
  constructor() {
    this.previous = null;
    this.current = null;
    this.map = /* @__PURE__ */ new Map();
  }
  alive() {
    return this.current != null;
  }
  begin() {
    this.previous = this.current;
    this.current = Symbol();
  }
  finish() {
    if (this.current == null) {
      return;
    }
    this.map.delete(this.current);
    this.current = this.previous;
  }
  get() {
    if (this.current == null) {
      return null;
    }
    return this.map.get(this.current) ?? null;
  }
  set(value) {
    if (this.current != null) {
      this.map.set(this.current, value);
    }
  }
  flush() {
    const value = this.get();
    this.set("");
    return value;
  }
}
const isPropertyAccessor = (v) => isString(v) || isNumber(v);
const NOT_DEFINED_VALUE = Symbol();
const ITERATE_CONTINUE = Symbol("continue");
const ITERATE_BREAK = Symbol("break");
const toString = (value, state) => {
  if (isFunction(value)) {
    throw error$1("a function cannot be output as string", state);
  }
  if (value == null) {
    return "";
  } else if (isPlainObject(value)) {
    return JSON.stringify(value);
  } else if (isArray(value)) {
    return value.join(",");
  } else if (isBoolean(value)) {
    return "";
  } else {
    return `${value}`;
  }
};
const strip = (value, start, end) => {
  let v = value;
  if (start)
    v = v.trimStart();
  if (end)
    v = v.trimEnd();
  return v;
};
const compileLiteral = (node) => {
  switch (node.type) {
    case "NullLiteral":
      return null;
    case "UndefinedLiteral":
      return void 0;
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
      return node.value;
  }
};
const compileIdentifier = (node, state) => {
  const {
    source,
    context: { variables, helpers }
  } = state;
  if (variables.has(node.name)) {
    return variables.get(node.name);
  }
  if (helpers.has(node.name)) {
    return helpers.get(node.name);
  }
  throw error$1(`"${node.name}" variable or helper function is not defined`, {
    source,
    range: node.range
  });
};
const compileMemberExpression = (node, state) => {
  const { source } = state;
  const object = compileExpression(node.object, state);
  let property;
  if (node.computed) {
    const v = compileExpression(node.property, state);
    if (!isPropertyAccessor(v)) {
      const t = typeOf(v);
      throw error$1(
        `Property access must be string or numeric (actual: "${t}")`,
        {
          source,
          range: node.property.range
        }
      );
    }
    property = v;
  } else {
    switch (node.property.type) {
      case "Identifier":
        property = node.property.name;
        break;
      case "NumericLiteral":
        property = node.property.value;
        break;
      default: {
        const t = node.property.type;
        throw error$1(
          `Static property access must be identifier or numeric (actual: "${t}")`,
          {
            source,
            range: node.property.range
          }
        );
      }
    }
  }
  assertDisallowedPath(property, {
    source,
    range: node.property.range
  });
  if (isObject(object)) {
    return object[property];
  } else if (isArray(object)) {
    return object[Number(property)];
  } else {
    const t = typeOf(object);
    throw error$1(
      `Property access is not available for data types other than object or array (actual: "${t}")`,
      {
        source,
        range: node.object.range
      }
    );
  }
};
function compileCallExpression(node, state) {
  const {
    source,
    context: { helpers }
  } = state;
  let helper;
  if (isIdentifier(node.callee)) {
    const v = helpers.get(node.callee.name);
    if (v == null) {
      throw error$1(`"${node.callee.name}" helper function is not defined`, {
        source,
        range: node.callee.range
      });
    }
    helper = v;
  } else if (isExpression(node.callee)) {
    const v = compileExpression(node.callee, state);
    if (!isFunction(v)) {
      const s = toString(v, {
        source,
        range: node.callee.range
      });
      const t = typeOf(v);
      throw error$1(`"${s !== "" ? s : t}" is not a function`, {
        source,
        range: node.callee.range
      });
    }
    helper = v;
  } else {
    throw error$1("Unexpected non-callable expression", {
      source,
      range: node.range
    });
  }
  const args = node.args.map((arg) => {
    return compileExpression(arg, state);
  });
  return helper(state.context, ...args);
}
function compilePrimaryExpression(node, state) {
  const { range } = node;
  if (isLiteral(node)) {
    return compileLiteral(node);
  } else if (isIdentifier(node)) {
    return compileIdentifier(node, state);
  } else if (isParenthesizedExpression(node)) {
    return compileExpression(node.expression, state);
  }
  throw error$1("Invalid node", {
    source: state.source,
    range
  });
}
function resolveVariablePaths(node, paths, state) {
  switch (node.type) {
    case "Identifier": {
      return [...paths, node.name];
    }
    case "MemberExpression": {
      const p1 = resolveVariablePaths(node.object, paths, state);
      if (p1 == null) {
        return null;
      }
      if (node.computed) {
        const v = compileExpression(node.property, state);
        return isPropertyAccessor(v) ? [...p1, v] : null;
      }
      return resolveVariablePaths(node.property, p1, state);
    }
    default: {
      const v = compileExpression(node, state);
      return isPropertyAccessor(v) ? [...paths, v] : null;
    }
  }
}
const disallowedPaths = /* @__PURE__ */ new Set(["__proto__", "prototype", "constructor"]);
const assertDisallowedPath = (path, state) => {
  if (isString(path) && disallowedPaths.has(path)) {
    throw error$1(`Invalid property access`, state);
  }
};
const getVariable = (obj, paths, state) => {
  if (!isObject(obj) && !isArray(obj) && !(obj instanceof Map)) {
    const t = typeOf(obj);
    throw error$1(
      `Property access is not available for data types other than object or array (actual: "${t}")`,
      state
    );
  }
  let o = obj;
  const get = (key) => {
    if (o instanceof Map) {
      return o.get(key);
    }
    return o instanceof Map ? o.get(key) : o[key];
  };
  for (let i = 0; i < paths.length; i++) {
    const key = paths[i];
    assertDisallowedPath(key, state);
    if (get(key) == null) {
      throw error$1(
        `Cannot read properties of "${o[key]}" (reading "${key}")`,
        state
      );
    }
    o = get(key);
  }
  return o;
};
const updateVariable = (obj, paths, value, state) => {
  if (!isObject(obj) && !isArray(obj) && !(obj instanceof Map)) {
    const t = typeOf(obj);
    throw error$1(
      `Property access is not available for data types other than object or array (actual: "${t}")`,
      state
    );
  }
  let o = obj;
  const get = (key) => {
    if (o instanceof Map) {
      return o.get(key);
    }
    return o instanceof Map ? o.get(key) : o[key];
  };
  for (let i = 0; i < paths.length; i++) {
    const key = paths[i];
    assertDisallowedPath(key, state);
    if (get(key) == null) {
      throw error$1(
        `Cannot read properties of "${o[key]}" (reading "${key}")`,
        state
      );
    }
    if (i === paths.length - 1) {
      if (o instanceof Map) {
        o.set(key, value);
      } else {
        o[key] = value;
      }
    }
    o = get(key);
  }
};
const compileUpdateExpression = (node, state) => {
  const {
    source,
    context: { variables }
  } = state;
  const paths = resolveVariablePaths(node.argument, [], state);
  if (paths == null || paths.length === 0) {
    throw error$1("Invalid left-hand side expression in prefix operation", {
      source,
      range: node.argument.range
    });
  }
  if (!variables.has(paths[0])) {
    throw error$1(`"${paths[0]}" is not defined`, {
      source,
      range: node.argument.range
    });
  }
  const old = getVariable(variables, paths, {
    source,
    range: node.argument.range
  });
  if (!isNumber(old)) {
    throw error$1(`"${old}" is not a number`, {
      source,
      range: node.argument.range
    });
  }
  let v;
  switch (node.operator) {
    case "++":
      v = old + 1;
      break;
    case "--":
      v = old - 1;
      break;
  }
  updateVariable(variables, paths, v, {
    source,
    range: node.argument.range
  });
  return node.prefix ? v : old;
};
const compileUnaryExpression = (node, state) => {
  const { source } = state;
  const arg = compileExpression(node.argument, state);
  switch (node.operator) {
    case "+":
    case "-":
    case "~": {
      if (isNumber(arg)) {
        switch (node.operator) {
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
        }
      }
      const t2 = typeOf(arg);
      throw error$1(
        `Unary operator "${node.operator}" cannot be applied to type "${t2}"`,
        {
          source,
          range: node.argument.range
        }
      );
    }
    case "!":
      if (isBoolean(arg)) {
        return !arg;
      }
      const t = typeOf(arg);
      throw error$1(`Unary operator "!" cannot be applied to type "${t}"`, {
        source,
        range: node.argument.range
      });
  }
};
const compileBinaryExpression = (node, state) => {
  const { source } = state;
  const left = compileExpression(node.left, state);
  const leftType = typeOf(left);
  const right = compileExpression(node.right, state);
  const rightType = typeOf(right);
  if (leftType !== rightType) {
    throw error$1(
      `The left and right values must be of the same data type (left: "${leftType}", right: "${rightType}")`,
      {
        source,
        range: node.range
      }
    );
  }
  switch (node.operator) {
    case "-":
    case "*":
    case "/":
    case "%":
    case "<":
    case ">":
    case "<=":
    case ">=": {
      if (isNumber(left) && isNumber(right)) {
        switch (node.operator) {
          case "-":
            return left - right;
          case "*":
            return left * right;
          case "/":
            if (right === 0) {
              return "Infinity";
            }
            return left / right;
          case "%":
            return left % right;
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
        }
      }
      throw error$1(
        `Operator "${node.operator}" cannot be applied to types "${leftType}" and "${rightType}"`,
        {
          source,
          range: node.range
        }
      );
    }
    case "+": {
      if (isString(left) && isString(right)) {
        return left + right;
      }
      if (isNumber(left) && isNumber(right)) {
        return left + right;
      }
      throw error$1(
        `Operator "+" cannot be applied to types "${leftType}" and "${rightType}"`,
        {
          source,
          range: node.range
        }
      );
    }
    case "==":
      return left === right;
    case "!=":
      return left !== right;
  }
};
const compileLogicalExpression = (node, state) => {
  const { source } = state;
  const left = compileExpression(node.left, state);
  const leftType = typeOf(left);
  const right = compileExpression(node.right, state);
  const rightType = typeOf(right);
  if (!isBoolean(left) && !isBoolean(right)) {
    throw error$1(
      `Operator "${node.operator}" cannot be applied to types "${leftType}" and "${rightType}"`,
      {
        source,
        range: node.range
      }
    );
  }
  switch (node.operator) {
    case "&&":
      return left && right;
    case "||":
      return left || right;
  }
};
const compileConditionalExpression = (node, state) => {
  const { source } = state;
  const test = compileExpression(node.test, state);
  if (!isBoolean(test)) {
    throw error$1(
      `The result of evaluation of the conditional expression should be a boolean (actual: "${typeOf(
        test
      )}")`,
      {
        source,
        range: node.test.range
      }
    );
  }
  return compileExpression(test ? node.consequent : node.alternate, state);
};
function compileExpression(node, state) {
  if (isPrimaryExpression(node)) {
    return compilePrimaryExpression(node, state);
  }
  switch (node.type) {
    case "CallExpression":
      return compileCallExpression(node, state);
    case "MemberExpression":
      return compileMemberExpression(node, state);
    case "UpdateExpression":
      return compileUpdateExpression(node, state);
    case "UnaryExpression":
      return compileUnaryExpression(node, state);
    case "BinaryExpression":
      return compileBinaryExpression(node, state);
    case "LogicalExpression":
      return compileLogicalExpression(node, state);
    case "ConditionalExpression":
      return compileConditionalExpression(node, state);
  }
}
const compileExpressionStatement = (node, state) => {
  const { source } = state;
  const v = compileExpression(node.expression, state);
  if (isFunction(v)) {
    return v(state.context);
  }
  return toString(v, {
    source,
    range: node.expression.range
  });
};
const compileVariableStatement = (node, state) => {
  const {
    source,
    context: { variables }
  } = state;
  const name = node.left.name;
  const v = compileExpression(node.right, state);
  if (isFunction(v)) {
    throw error$1("Variable assignment of functions is not allowed", {
      source,
      range: node.right.range
    });
  }
  variables.set(name, v);
  return "";
};
const compileIfStatement = (node, state) => {
  const { source } = state;
  const { ifClose, elseOpen, elseClose, endOpen } = node.tags;
  const test = compileExpression(node.test, state);
  if (!isBoolean(test)) {
    throw error$1(
      `The result of evaluation of the conditional expression should be a boolean (actual: "${typeOf(
        test
      )}")`,
      {
        source,
        range: node.test.range
      }
    );
  }
  if (test) {
    return strip(
      toString(compileTemplate(node.consequent, state), {
        source,
        range: node.range
      }),
      ifClose.strip,
      (elseOpen?.strip || endOpen?.strip) ?? false
    );
  }
  if (isIfStatement(node.alternate)) {
    return compileIfStatement(node.alternate, state);
  } else if (isArray(node.alternate)) {
    return strip(
      toString(compileTemplate(node.alternate, state), {
        source,
        range: node.range
      }),
      elseClose.strip,
      endOpen.strip
    );
  } else {
    return "";
  }
};
const compileForStatement = (node, state) => {
  const {
    source,
    iterate,
    context: { variables }
  } = state;
  const { close, open } = node.tags;
  iterate.begin();
  const refs = {
    value: node.value.name,
    index: node.index?.name ?? null
  };
  const vars = {
    value: variables.has(refs.value) ? variables.get(refs.value) : NOT_DEFINED_VALUE,
    index: refs.index != null && variables.has(refs.index) ? variables.get(refs.index) : NOT_DEFINED_VALUE
  };
  const right = compileExpression(node.right, state);
  if (!isArray(right)) {
    const t = typeOf(right);
    throw error$1(
      `Right-hand side expression must be iterable (actual: "${t}")`,
      {
        source,
        range: node.right.range
      }
    );
  }
  let result = "";
  for (let i = 0; i < right.length; i++) {
    const v = right[i];
    variables.set(refs.value, v);
    if (refs.index != null) {
      variables.set(refs.index, i);
    }
    try {
      result += strip(
        toString(compileTemplate(node.body, state), {
          source,
          range: node.range
        }),
        close.strip,
        open.strip
      );
      iterate.set("");
    } catch (e) {
      if (e === ITERATE_CONTINUE) {
        result += iterate.flush() ?? "";
        continue;
      }
      if (e === ITERATE_BREAK) {
        result += iterate.flush() ?? "";
        break;
      }
      throw e;
    }
  }
  if (vars.value !== NOT_DEFINED_VALUE) {
    variables.set(refs.value, vars.value);
  }
  if (vars.index !== NOT_DEFINED_VALUE && refs.index != null) {
    variables.set(refs.index, vars.index);
  }
  iterate.finish();
  return strip(result, close.strip, open.strip);
};
const compileContinueStatement = () => {
  throw ITERATE_CONTINUE;
};
const compileBreakStatement = () => {
  throw ITERATE_BREAK;
};
const compileTagTemplate = (node, state) => {
  if (node.body == null) {
    return "";
  }
  switch (node.body.type) {
    case "ExpressionStatement":
      return compileExpressionStatement(node.body, state);
    case "VariableStatement":
      return compileVariableStatement(node.body, state);
    case "IfStatement":
      return compileIfStatement(node.body, state);
    case "ForStatement":
      return compileForStatement(node.body, state);
    case "ContinueStatement":
      return compileContinueStatement(node.body);
    case "BreakStatement":
      return compileBreakStatement(node.body);
  }
};
const compileRawTemplate = (node) => {
  return node.body;
};
const compileTemplate = (nodes, state) => {
  const { source, iterate } = state;
  if (nodes.length === 0) {
    return "";
  }
  const buffer = nodes.reduce((acc, node) => {
    let current;
    let open = null;
    let close = null;
    switch (node.type) {
      case "RawTemplate":
        current = toString(compileRawTemplate(node), {
          source,
          range: node.range
        });
        break;
      case "TagTemplate":
        open = node.open.strip;
        close = node.close.strip;
        current = toString(compileTagTemplate(node, state), {
          source,
          range: node.range
        });
        break;
    }
    if (iterate.alive()) {
      const previous = strip(iterate.get() ?? "", false, open != null);
      iterate.set(previous + current);
    }
    acc.push([current, open, close]);
    return acc;
  }, []);
  const output = buffer.reduce((acc, [str, open, close], index) => {
    if (open == null && close == null) {
      if (buffer[index + 1]?.[1]) {
        str = str.trimEnd();
      }
      if (buffer[index - 1]?.[2]) {
        acc = acc.trimEnd();
        str = str.trimStart();
      }
    } else {
      if (open) {
        acc = acc.trimEnd();
        str = str.trimStart();
      }
      if (close) {
        str = str.trimEnd();
      }
    }
    return acc + str;
  }, "");
  return output;
};
const compileProgram = (node, state) => {
  return compileTemplate(node.body, state);
};
const compile = (ast, context) => {
  return toString(
    compileProgram(ast, {
      source: ast.source,
      iterate: new IterateState(),
      context
    }),
    {
      source: ast.source,
      range: ast.range
    }
  );
};

const createHelper = (fn, options = {}) => {
  const opts = {
    disableAutoLoop: options?.disableAutoLoop === true
  };
  if (opts.disableAutoLoop) {
    return fn;
  }
  return (ctx, ...args) => {
    const f = fn.bind(null, ctx);
    if (isNonNullish(args[0]) && isArray(args[0])) {
      const rest = args.slice(1);
      return args[0].map((v) => f(v, ...rest));
    } else {
      return f(...args);
    }
  };
};
const defineHelper = (helpers, name, fn, options = {}) => {
  helpers.set(name, createHelper(fn, options));
};

const helpers = /* @__PURE__ */ new Map();
const splitLines = (v) => v.split(/\r?\n/);
defineHelper(
  helpers,
  "split",
  (_, v, sep) => v.split(sep)
);
defineHelper(
  helpers,
  "join",
  (_, v, sep) => v.join(sep),
  {
    disableAutoLoop: true
  }
);
defineHelper(
  helpers,
  "seq",
  (_, first, increment, last) => {
    const iter = {
      start: first,
      step: 1,
      end: 0
    };
    if (isNumber(increment) && isNumber(last)) {
      iter.step = increment;
      iter.end = last;
    } else if (isNumber(increment)) {
      iter.end = increment;
    } else {
      iter.start = 1;
      iter.end = first;
    }
    const arr = [];
    let n = iter.start;
    while (n <= iter.end) {
      arr.push(n);
      n += iter.step;
    }
    return arr;
  },
  {
    disableAutoLoop: true
  }
);
defineHelper(
  helpers,
  "append",
  (_, v, ...args) => [...v, ...args],
  {
    disableAutoLoop: true
  }
);
defineHelper(
  helpers,
  "uniq",
  (_, v) => Array.from(new Set(v)),
  {
    disableAutoLoop: true
  }
);
defineHelper(helpers, "s2n", (_, v) => {
  const n = Number(v);
  return Number.isNaN(n) ? 0 : n;
});
defineHelper(helpers, "n2s", (_, v) => String(v));
defineHelper(
  helpers,
  "len",
  (_, v) => {
    if (isString(v) || isArray(v)) {
      return v.length;
    }
    if (isNumber(v)) {
      return v.toString().length;
    }
    if (isObject(v)) {
      return Object.keys(v).length;
    }
    return 0;
  },
  {
    disableAutoLoop: true
  }
);
defineHelper(
  helpers,
  "slice",
  (_, v, start, end) => {
    if (isString(v) || isArray(v)) {
      return v.slice(start, end);
    }
    throw new Error(
      `slice helper expecting string or array value but got "${typeOf(v)}"`
    );
  },
  {
    disableAutoLoop: true
  }
);
defineHelper(
  helpers,
  "contains",
  (_, search, item) => {
    if (isString(search) || isArray(search)) {
      return search.includes(item);
    }
    throw new Error(
      `contains helper expecting string or array value but got "${typeOf(
        search
      )}"`
    );
  },
  {
    disableAutoLoop: true
  }
);
defineHelper(helpers, "camel", (_, v) => cc.camelCase(v));
defineHelper(helpers, "snake", (_, v) => cc.snakeCase(v));
defineHelper(helpers, "pascal", (_, v) => cc.pascalCase(v));
defineHelper(helpers, "kebab", (_, v) => cc.kebabCase(v));
defineHelper(helpers, "constant", (_, v) => cc.constantCase(v));
defineHelper(helpers, "upper", (_, v) => v.toUpperCase());
defineHelper(helpers, "lower", (_, v) => v.toLowerCase());
defineHelper(
  helpers,
  "plur",
  (_, v, count = 2) => plur(v, count)
);
defineHelper(
  helpers,
  "replace",
  (_, v, pattern, replacement) => v.replace(new RegExp(pattern, "g"), replacement)
);
defineHelper(helpers, "trim", (_, v) => v.trim());
defineHelper(helpers, "ltrim", (_, v) => v.trimStart());
defineHelper(helpers, "rtrim", (_, v) => v.trimEnd());
defineHelper(
  helpers,
  "before",
  (_, v, n, offset) => {
    const lines = splitLines(v);
    const off = offset ?? 0;
    if (typeof n === "string") {
      const regexp = new RegExp(n);
      for (let i = 0; i < lines.length; i++) {
        if (regexp.test(lines[i])) {
          return lines.slice(0, i + off).join("\n");
        }
      }
      return v;
    }
    return lines.slice(0, n - 1 + off).join("\n");
  }
);
defineHelper(
  helpers,
  "after",
  (_, v, n, offset) => {
    const lines = splitLines(v);
    const off = offset ?? 0;
    if (typeof n === "string") {
      const regexp = new RegExp(n);
      for (let i = 0; i < lines.length; i++) {
        if (regexp.test(lines[i])) {
          return lines.slice(i + 1 + off).join("\n");
        }
      }
      return v;
    }
    return lines.slice(n + off).join("\n");
  }
);
defineHelper(helpers, "date", (_, format) => {
  const d = dayjs();
  return format ? d.format(format) : d.toISOString();
});
defineHelper(helpers, "noop", () => "");
defineHelper(helpers, "define", (ctx, v, key) => {
  ctx.variables.set(key, v);
  return "";
});

const defaults = Object.freeze({
  tags: ["{{", "}}"]
});

const mergeMap = (map1, map2) => new Map([...map1, ...map2]);
const extendContext = (context, partial) => {
  const ctx = { ...context };
  ctx.cwd = partial.cwd ?? ctx.cwd;
  ctx.tags = partial.tags ?? ctx.tags;
  if (partial.helpers != null) {
    ctx.helpers = mergeMap(ctx.helpers, partial.helpers);
  }
  if (partial.variables != null) {
    ctx.variables = mergeMap(ctx.variables, partial.variables);
  }
  return ctx;
};
const createContext = (partial) => extendContext(
  {
    cwd: process.cwd(),
    helpers,
    variables: /* @__PURE__ */ new Map(),
    tags: defaults.tags
  },
  partial
);

const unicodeIdStartReg = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]/;
const unicodeIdContinueReg = /[0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0898-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1715\u171F-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B4C\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA827\uA82C\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDEFD-\uDF1C\uDF27\uDF30-\uDF50\uDF70-\uDF85\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC75\uDC7F-\uDCBA\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E-\uDE41\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39\uDF40-\uDF46]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDF00-\uDF10\uDF12-\uDF3A\uDF3E-\uDF42\uDF50-\uDF59\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC40-\uDC55]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC30-\uDC6D\uDC8F\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAE\uDEC0-\uDEF9]|\uD839[\uDCD0-\uDCF9\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]|\uDB40[\uDD00-\uDDEF]/;

const reservedWord$1 = /* @__PURE__ */ new Set([
  "null",
  "undefined",
  "true",
  "false",
  "if",
  "else",
  "for",
  "break",
  "continue",
  "end"
]);
const join = (arr, separator) => arr.filter(Boolean).join(separator);
const isValidIdentifierName = (value) => {
  if (reservedWord$1.has(value)) {
    return false;
  }
  const [first, ...rest] = [...value];
  return unicodeIdStartReg.test(first) && rest.every((v) => unicodeIdContinueReg.test(v));
};
const formatComment = (node) => {
  const lines = node.body.split("\n");
  if (lines.length > 1) {
    const body = lines.map((ln) => ln.trimEnd()).join("\n");
    return `/*${body}*/`;
  }
  return `/* ${node.body.trim()} */`;
};
const formatComments = (comments) => {
  return comments.map((comment) => formatComment(comment)).join(" ");
};
const formatLiteral = (node) => {
  const leading = formatComments(node.leadingComments);
  const trailing = formatComments(node.trailingComments);
  switch (node.type) {
    case "NullLiteral":
      return join([leading, "null", trailing], " ");
    case "UndefinedLiteral":
      return join([leading, "undefined", trailing], " ");
    case "BooleanLiteral":
    case "NumericLiteral":
      return join([leading, node.value.toString(), trailing], " ");
    case "StringLiteral":
      return join(
        [leading, `${node.quote}${node.value}${node.quote}`, trailing],
        " "
      );
  }
};
const formatIdentifier = (node) => {
  return join(
    [
      formatComments(node.leadingComments),
      node.name,
      formatComments(node.trailingComments)
    ],
    " "
  );
};
const formatPrimaryExpression = (node) => {
  if (isLiteral(node)) {
    return formatLiteral(node);
  }
  switch (node.type) {
    case "Identifier":
      return formatIdentifier(node);
    case "ParenthesizedExpression":
      return formatParenthesizedExpression(node);
  }
};
const formatLeftHandSideExpression = (node) => {
  if (isPrimaryExpression(node)) {
    return formatPrimaryExpression(node);
  }
  switch (node.type) {
    case "CallExpression":
      return formatCallExpression(node);
    case "MemberExpression":
      return formatMemberExpression(node);
  }
};
function formatCallExpression(node) {
  const callee = formatExpression(node.callee);
  const formatArgs = (args, delimiter) => {
    return args.map((arg) => formatExpression(arg)).join(delimiter);
  };
  if (node.piped) {
    const [first, ...rest] = node.args;
    if (isCallExpression(first)) {
      return join(
        [formatCallExpression(first), "|", callee, formatArgs(rest, " ")],
        " "
      );
    } else if (node.callee.range[0] > (first?.range[0] ?? 0)) {
      return join(
        [formatExpression(first), "|", callee, formatArgs(rest, " ")],
        " "
      );
    } else {
      return join([callee, formatArgs(node.args, " ")], " ");
    }
  }
  return join(
    [
      callee,
      "(",
      formatArgs(node.args, ", "),
      formatComments(node.innerComments),
      ")"
    ],
    ""
  );
}
function formatMemberExpression(node) {
  let obj;
  if (isPrimaryExpression(node.object)) {
    obj = formatPrimaryExpression(node.object);
  } else {
    switch (node.object.type) {
      case "MemberExpression":
        obj = formatMemberExpression(node.object);
        break;
      case "CallExpression":
        obj = formatCallExpression(node.object);
        break;
    }
  }
  if (!node.computed) {
    switch (node.property.type) {
      case "StringLiteral":
      case "NumericLiteral":
        return `${obj}.${node.property.value}`;
      default: {
        const prop2 = formatExpression(node.property);
        return `${obj}.${prop2}`;
      }
    }
  }
  if ((isStringLiteral(node.property) && isValidIdentifierName(node.property.value) || isNumericLiteral(node.property)) && node.property.leadingComments.length < 1 && node.property.trailingComments.length < 1) {
    return `${obj}.${node.property.value}`;
  }
  const prop = join(
    [
      formatComments(node.leadingComments),
      formatExpression(node.property),
      formatComments(node.trailingComments)
    ],
    " "
  );
  return `${obj}[${prop}]`;
}
function formatParenthesizedExpression(node) {
  const body = join(
    [
      formatComments(node.leadingComments),
      formatExpression(node.expression),
      formatComments(node.trailingComments)
    ],
    " "
  );
  return `(${body})`;
}
const formatUpdateExpression = (node) => {
  const arg = formatLeftHandSideExpression(node.argument);
  const expr = node.prefix ? `${node.operator}${arg}` : `${arg}${node.operator}`;
  return join(
    [
      formatComments(node.leadingComments),
      expr,
      formatComments(node.trailingComments)
    ],
    " "
  );
};
const formatUnaryExpression = (node) => {
  const arg = formatExpression(node.argument);
  return join(
    [
      formatComments(node.leadingComments),
      `${node.operator}${arg}`,
      formatComments(node.trailingComments)
    ],
    " "
  );
};
const formatBinaryExpression = (node) => {
  return join(
    [
      formatComments(node.leadingComments),
      formatExpression(node.left),
      node.operator,
      formatExpression(node.right),
      formatComments(node.trailingComments)
    ],
    " "
  );
};
const formatLogicalExpression = (node) => {
  return join(
    [
      formatComments(node.leadingComments),
      formatExpression(node.left),
      node.operator,
      formatExpression(node.right),
      formatComments(node.trailingComments)
    ],
    " "
  );
};
const formatConditionalExpression = (node) => {
  return join(
    [
      formatComments(node.leadingComments),
      formatExpression(node.test),
      "?",
      formatExpression(node.consequent),
      ":",
      formatExpression(node.alternate),
      formatComments(node.trailingComments)
    ],
    " "
  );
};
function formatExpression(node) {
  if (isPrimaryExpression(node)) {
    return formatPrimaryExpression(node);
  }
  switch (node.type) {
    case "MemberExpression":
      return formatMemberExpression(node);
    case "CallExpression":
      return formatCallExpression(node);
    case "UpdateExpression":
      return formatUpdateExpression(node);
    case "UnaryExpression":
      return formatUnaryExpression(node);
    case "BinaryExpression":
      return formatBinaryExpression(node);
    case "LogicalExpression":
      return formatLogicalExpression(node);
    case "ConditionalExpression":
      return formatConditionalExpression(node);
  }
}
const formatExpressionStatement = (node) => {
  return formatExpression(node.expression);
};
const formatVariableStatement = (node) => {
  return join(
    [
      formatComments(node.leadingComments),
      formatIdentifier(node.left),
      ":=",
      formatExpression(node.right),
      formatComments(node.trailingComments)
    ],
    " "
  );
};
const formatIfStatement = (node) => {
  const output = join(
    [
      "if ",
      formatExpression(node.test),
      " ",
      formatTag(node.tags.ifClose),
      formatTemplate(node.consequent)
    ],
    ""
  );
  if (node.alternate == null) {
    return join([output, formatTag(node.tags.endOpen), " end"], "");
  }
  if (isIfStatement(node.alternate)) {
    return join(
      [
        output,
        formatTag(node.tags.elseOpen),
        " else ",
        formatIfStatement(node.alternate)
      ],
      ""
    );
  }
  return join(
    [
      output,
      formatTag(node.tags.elseOpen),
      " else ",
      formatTag(node.tags.elseClose),
      formatTemplate(node.alternate),
      formatTag(node.tags.endOpen),
      " end"
    ],
    ""
  );
};
const formatForStatement = (node) => {
  return join(
    [
      "for ",
      formatIdentifier(node.value),
      node.index && join([", ", formatIdentifier(node.index)], ""),
      " in ",
      formatExpression(node.right),
      " ",
      formatTag(node.tags.close),
      formatTemplate(node.body),
      formatTag(node.tags.open),
      " end"
    ],
    ""
  );
};
const formatStatement = (node) => {
  switch (node.type) {
    case "ExpressionStatement":
      return formatExpressionStatement(node);
    case "VariableStatement":
      return formatVariableStatement(node);
    case "IfStatement":
      return formatIfStatement(node);
    case "ForStatement":
      return formatForStatement(node);
    case "ContinueStatement":
      return join(
        [
          formatComments(node.leadingComments),
          "continue",
          formatComments(node.trailingComments)
        ],
        " "
      );
    case "BreakStatement":
      return join(
        [
          formatComments(node.leadingComments),
          "break",
          formatComments(node.trailingComments)
        ],
        " "
      );
  }
};
const formatTag = (node) => {
  const leading = formatComments(node.leadingComments);
  const trailing = formatComments(node.trailingComments);
  const strip = node.strip ? "-" : "";
  switch (node.variant) {
    case "open":
      return join([`${node.delimiter}${strip}`, trailing], " ");
    case "close":
      return join([leading, `${strip}${node.delimiter}`], " ");
  }
};
const formatTagTemplate = (node) => {
  const open = formatTag(node.open);
  const close = formatTag(node.close);
  return join(
    [
      open,
      formatComments(node.leadingComments),
      node.body != null ? formatStatement(node.body) : "",
      formatComments(node.trailingComments),
      close
    ],
    " "
  );
};
const formatRawTemplate = (node) => {
  return node.body;
};
const formatTemplate = (nodes) => {
  return nodes.reduce((acc, cur) => {
    switch (cur.type) {
      case "RawTemplate":
        return acc + formatRawTemplate(cur);
      case "TagTemplate":
        return acc + formatTagTemplate(cur);
    }
  }, "");
};
const format = (ast) => {
  return formatTemplate(ast.body);
};

const parseError = (message, range) => ({
  message,
  range
});
class ParseErrorStack {
  constructor(errors) {
    this.errors = errors;
  }
  static from(errors) {
    return new ParseErrorStack(errors);
  }
  all() {
    return this.errors;
  }
  clear() {
    const stack = ParseErrorStack.from([]);
    return stack;
  }
  latest() {
    return this.errors[this.errors.length - 1] ?? null;
  }
  upsert(from, to) {
    if (from == null) {
      return ParseErrorStack.from([...this.errors, to]);
    }
    const index = this.errors.findIndex((entry) => entry === from);
    if (index < 0) {
      return ParseErrorStack.from([...this.errors, to]);
    }
    return ParseErrorStack.from([
      ...this.errors.slice(0, index),
      to,
      ...this.errors.slice(index + 1)
    ]);
  }
  append(entry) {
    const stack = ParseErrorStack.from([...this.errors, entry]);
    return stack;
  }
  [Symbol.iterator]() {
    let index = -1;
    return {
      next: () => ({
        value: this.errors[++index],
        done: index === this.errors.length
      })
    };
  }
}

const success = (data, committed, state) => ({
  type: "success",
  data,
  committed,
  state
});
const error = (kind, committed, state) => ({
  type: "error",
  kind,
  committed,
  state
});
const some = (value) => ({
  state: "some",
  value
});
const none = () => ({
  state: "none"
});

const satisfy = (fn) => (state) => {
  if (state.input.length > 0 && typeof state.input[0] === "string" && fn(state.input[0])) {
    const [data, ...rest] = state.input;
    return success(data, true, {
      ...state,
      rest,
      offset: state.offset + 1
    });
  }
  return error("error", false, {
    ...state,
    rest: state.input
  });
};
const eof = (state) => {
  return state.input.length === 0 ? success(null, false, state) : error("error", false, {
    ...state,
    rest: state.input
  });
};
const any = satisfy(() => true);
const char = (c) => (state) => {
  const r = satisfy((v) => v === c)(state);
  if (r.type === "error") {
    const found = state.input[0];
    const msg = found != null ? `"${c}" expected but "${found}" found` : `"${c}" expected`;
    return error(r.kind, r.committed, {
      ...r.state,
      errors: r.state.errors.append(
        parseError(msg, [state.offset, state.offset])
      )
    });
  }
  return success(r.data, true, r.state);
};
const label = (p, msg) => (state) => {
  const r = p(state);
  if (r.type === "error") {
    return error(r.kind, false, {
      ...r.state,
      errors: r.state.errors.append({
        message: msg,
        range: [state.offset, r.state.offset]
      })
    });
  }
  return r;
};
const expected = (p, msg) => (state) => {
  const r = p(state);
  if (r.type === "error" && !r.committed) {
    return error(r.kind, false, {
      ...r.state,
      errors: r.state.errors.upsert(
        r.state.errors.latest(),
        parseError(msg, [state.offset, r.state.offset])
      )
    });
  }
  return r;
};
const peek = (p) => (state) => {
  const r = p(state);
  const s = {
    ...state,
    rest: state.input
  };
  return r.type === "error" ? error("error", false, s) : success(r.data, false, s);
};
const cut = (p) => (state) => {
  const r = p(state);
  if (r.type === "error" && r.kind === "error") {
    return error("failure", r.committed, r.state);
  }
  return r;
};
const attempt = (p) => (state) => {
  const r = p(state);
  if (r.type === "error") {
    if (r.kind === "failure") {
      return r;
    }
    if (r.committed) {
      return error("error", false, r.state);
    }
  }
  return r;
};
const map = (p, f) => (state) => {
  const r = p(state);
  if (r.type === "error") {
    return r;
  }
  return success(f(r.data, [state.offset, r.state.offset - 1]), true, r.state);
};
const concat = (ps) => (state) => {
  const rs = [];
  let s = state;
  for (const p of ps) {
    const r = p(s);
    if (r.type === "error") {
      return error(r.kind, r.committed || rs.length > 0, {
        ...r.state,
        input: state.input
      });
    }
    rs.push(r.data);
    s = {
      ...r.state,
      input: r.state.rest
    };
  }
  return success(
    rs,
    rs.length > 0,
    {
      ...s,
      input: state.input,
      rest: s.input
    }
  );
};
const preceded = (p1, p2) => (state) => {
  const r = p1(state);
  if (r.type === "error") {
    return r;
  }
  return p2({
    ...r.state,
    input: r.state.rest
  });
};
const choice = (ps) => (state) => {
  let s = state;
  for (const p of ps) {
    const r = p(state);
    if (r.type === "error" && r.kind === "failure" || r.committed) {
      return r;
    }
    s = r.state;
  }
  return error("error", false, s);
};
const digit = label(
  satisfy((c) => /^\d$/.test(c)),
  "Expected a number from 0 to 9"
);
const string = (s) => (state) => {
  const r = concat([...s].map(char))(state);
  if (r.type === "error") {
    const latest = r.state.errors.latest();
    const msg = latest == null ? `"${s}" expected` : `"${s}" expected (${latest.message})`;
    return error(r.kind, r.committed, {
      ...r.state,
      errors: r.state.errors.upsert(latest, {
        message: msg,
        range: [state.offset, r.state.offset]
      })
    });
  }
  return success(s, true, r.state);
};
const option = (p) => (state) => {
  const r = p(state);
  if (r.type === "error") {
    if (r.kind === "failure" || r.committed) {
      return r;
    }
    return success(none(), false, {
      ...r.state,
      errors: state.errors
    });
  }
  return success(some(r.data), true, r.state);
};
const not = (p) => (state) => {
  const r = p(state);
  if (r.type === "success") {
    return error("error", false, {
      ...state,
      rest: state.input
    });
  }
  return success(null, false, {
    ...state,
    rest: state.input
  });
};
const diff = (p, q) => map(attempt(concat([not(q), p])), ([, r]) => r);
const many = (p) => (state) => {
  const rs = [];
  let s = state;
  for (let i = 0; i < Number.POSITIVE_INFINITY; i++) {
    const r = p(s);
    if (r.type === "error") {
      if (r.kind === "failure" || r.committed) {
        return error(r.kind, r.committed, {
          ...r.state,
          input: state.input
        });
      }
      break;
    }
    rs.push(r.data);
    s = {
      ...r.state,
      input: r.state.rest
    };
  }
  return success(rs, rs.length > 0, {
    ...s,
    input: state.input,
    rest: s.input
  });
};
const many1 = (p) => (state) => {
  const r = many(p)(state);
  if (r.type === "error") {
    return r;
  }
  if (r.data.length === 0) {
    return error("error", false, r.state);
  }
  return r;
};
const manyTill = (p, q) => (state) => {
  const rs = [];
  let s = state;
  while (true) {
    const qr = q(s);
    if (qr.type === "success") {
      return success([rs, qr.data], true, {
        ...qr.state,
        input: state.input,
        rest: qr.state.rest
      });
    }
    const pr = p(s);
    if (pr.type === "error") {
      return error(pr.kind, pr.committed || rs.length > 0, {
        ...pr.state,
        input: state.input
      });
    }
    rs.push(pr.data);
    s = {
      ...pr.state,
      input: pr.state.rest
    };
  }
};
const list = (p, delimiter) => map(concat([p, many(concat([delimiter, p]))]), ([first, rest]) => [
  first,
  ...rest.map(([, r]) => r)
]);

const whitespaceChar = choice([..."	\n\r "].map(char));
const whitespace = map(many(whitespaceChar), () => null);
const whitespace1 = map(many1(whitespaceChar), () => null);

const comment = map(
  concat([
    peek(string("/*")),
    preceded(
      string("/*"),
      cut(
        concat([
          many(diff(any, string("*/"))),
          label(string("*/"), 'Missing "*/"')
        ])
      )
    )
  ]),
  ([, [body]], r) => createComment(body.join(""), r)
);
const whitespaceOrComment = map(
  concat([whitespace, many(concat([comment, whitespace]))]),
  ([, d]) => d.map(([c]) => c)
);

const nullLiteral = map(
  expected(string("null"), "null literal expected"),
  (_, r) => createNullLiteral(r)
);
const undefinedLiteral = map(
  expected(string("undefined"), "undefined literal expected"),
  (_, r) => createUndefinedLiteral(r)
);
const booleanLiteral = map(
  expected(
    choice([
      map(string("true"), () => true),
      map(string("false"), () => false)
    ]),
    "boolean literal expected"
  ),
  (v, r) => createBooleanLiteral(v, r)
);
const binaryDigitPrefix = map(
  concat([char("0"), choice([char("b"), char("B")])]),
  () => "0b"
);
const binaryDigit = choice([char("0"), char("1")]);
const binaryDigits = map(
  label(many1(binaryDigit), "Invalid binary digit"),
  (rest) => rest.join("")
);
const binaryIntegerLiteral = map(
  concat([
    peek(binaryDigitPrefix),
    preceded(binaryDigitPrefix, cut(binaryDigits))
  ]),
  (rest) => Number(rest.join(""))
);
const octalDigitPrefix = map(
  concat([char("0"), choice([char("o"), char("O")])]),
  () => "0o"
);
const octalDigit = satisfy((c) => /^[0-7]$/.test(c));
const octalDigits = map(
  label(many1(octalDigit), "Invalid octal digit"),
  (rest) => rest.join("")
);
const octalIntegerLiteral = map(
  concat([
    peek(octalDigitPrefix),
    preceded(octalDigitPrefix, cut(octalDigits))
  ]),
  (rest) => Number(rest.join(""))
);
const hexDigitPrefix = map(
  concat([char("0"), choice([char("x"), char("X")])]),
  () => "0x"
);
const hexDigit = satisfy((c) => /^([0-9]|[a-f])$/i.test(c));
const hexDigits = map(
  label(many1(hexDigit), "Invalid hex digit"),
  (rest) => rest.join("")
);
const hexIntegerLiteral = map(
  concat([peek(hexDigitPrefix), preceded(hexDigitPrefix, cut(hexDigits))]),
  (rest) => Number(rest.join(""))
);
const nonZeroDigit = diff(digit, char("0"));
const decimalDigits = map(
  many1(digit),
  (rest) => rest.join("")
);
const decimalInteger = choice([
  char("0"),
  map(
    concat([nonZeroDigit, option(decimalDigits)]),
    ([first, rest]) => [first, rest.state === "some" ? rest.value : ""].join("")
  )
]);
const signedInteger = choice([
  map(concat([char("+"), decimalDigits]), (rest) => rest.join("")),
  map(concat([char("-"), decimalDigits]), (rest) => rest.join("")),
  decimalDigits
]);
const exponentIndicator = choice([char("e"), char("E")]);
const exponentPart = map(
  concat([
    exponentIndicator,
    cut(label(signedInteger, "Invalid exponent part"))
  ]),
  (rest) => rest.join("")
);
const decimalLiteral = choice([
  // "." DecimalDigits ExponentPart?
  map(
    concat([
      peek(concat([char("."), decimalDigits])),
      preceded(concat([char("."), decimalDigits]), option(exponentPart))
    ]),
    ([[, fraction], exponent]) => Number(
      [
        "0",
        ".",
        fraction,
        exponent.state === "some" ? exponent.value : ""
      ].join("")
    )
  ),
  // DecimalIntegerLiteral "." DecimalDigits? ExponentPart?
  map(
    concat([
      peek(concat([decimalInteger, char(".")])),
      preceded(
        concat([decimalInteger, char(".")]),
        concat([option(decimalDigits), option(exponentPart)])
      )
    ]),
    ([[integer], [fraction, exponent]]) => Number(
      [
        integer,
        ".",
        fraction.state === "some" ? fraction.value : "",
        exponent.state === "some" ? exponent.value : ""
      ].join("")
    )
  ),
  // DecimalIntegerLiteral ExponentPart?
  map(
    concat([
      peek(decimalInteger),
      preceded(decimalInteger, option(exponentPart))
    ]),
    ([integer, exponent]) => Number(
      [integer, exponent.state === "some" ? exponent.value : ""].join("")
    )
  )
]);
const numericLiteral = map(
  choice([
    binaryIntegerLiteral,
    octalIntegerLiteral,
    hexIntegerLiteral,
    decimalLiteral
  ]),
  (v, r) => createNumericLiteral(v, r)
);
const doubleQuote = char(`"`);
const singleQuote = char(`'`);
const escape = choice([
  attempt(map(string(`\\"`), () => `"`)),
  map(string(`\\'`), () => `'`)
]);
const doubleStringChars = map(
  many(choice([attempt(escape), diff(any, doubleQuote)])),
  (rest) => rest.join("")
);
const singleStringChars = map(
  many(choice([attempt(escape), diff(any, singleQuote)])),
  (rest) => rest.join("")
);
const doubleStringLiteral = map(
  concat([
    doubleQuote,
    doubleStringChars,
    expected(cut(doubleQuote), "Missing double quote")
  ]),
  ([, s], r) => createStringLiteral(s, `"`, r)
);
const singleStringLiteral = map(
  concat([
    singleQuote,
    singleStringChars,
    expected(cut(singleQuote), "Missing single quote")
  ]),
  ([, s], r) => createStringLiteral(s, `'`, r)
);
const stringLiteral = choice([
  attempt(doubleStringLiteral),
  singleStringLiteral
]);
const literal = choice([
  nullLiteral,
  undefinedLiteral,
  booleanLiteral,
  numericLiteral,
  stringLiteral
]);
const tagOpen = (state) => map(
  concat([string(state.tags[0]), option(char("-"))]),
  ([delimiter, strip], r) => createTag("open", delimiter, strip.state === "some", r)
)(state);
const tagClose = (state) => map(
  attempt(concat([option(char("-")), string(state.tags[1])])),
  ([strip, delimiter], r) => createTag("close", delimiter, strip.state === "some", r)
)(state);

const unicodeIdStart = satisfy(
  (c) => unicodeIdStartReg.test(c)
);
const unicodeIdContinue = satisfy(
  (c) => unicodeIdContinueReg.test(c)
);
const identifierStart = choice([
  char("$"),
  char("_"),
  unicodeIdStart
]);
const identifierPart = choice([
  char("$"),
  char("_"),
  unicodeIdContinue
]);
const reservedWord = choice([
  attempt(string("null")),
  attempt(string("undefined")),
  attempt(string("true")),
  attempt(string("false")),
  attempt(string("if")),
  attempt(string("else")),
  attempt(string("for")),
  attempt(string("break")),
  attempt(string("continue")),
  string("end")
]);
const identifierName = map(
  expected(
    concat([identifierStart, many(choice([identifierStart, identifierPart]))]),
    "Invalid identifier name"
  ),
  ([first, rest]) => [first, ...rest].join("")
);
const identifier = (state) => {
  const r1 = identifierName(state);
  if (r1.type === "error") {
    return r1;
  }
  const r2 = reservedWord(state);
  if (r2.type === "success" && r1.data === r2.data) {
    return error("error", false, {
      ...r2.state,
      errors: r2.state.errors.append({
        message: `"${r2.data}" is a reserved word and cannot be used as an identifier`,
        range: [state.offset, r2.state.offset - 1]
      })
    });
  }
  return success(
    createIdentifier(r1.data, [state.offset, r1.state.offset - 1]),
    true,
    r1.state
  );
};
const primaryExpression = choice([
  attempt(literal),
  attempt(identifier),
  parenthesizedExpression
]);
const staticMemberAccessor = choice([
  attempt(identifier),
  numericLiteral
]);
function memberExpression(state) {
  return map(
    concat([
      primaryExpression,
      many(
        choice([
          attempt(
            map(
              preceded(
                char("."),
                cut(expected(staticMemberAccessor, "Missing member property"))
              ),
              (p) => [p, false]
            )
          ),
          map(
            concat([
              char("["),
              whitespaceOrComment,
              cut(expected(expression, 'Missing expression after "["')),
              whitespaceOrComment,
              cut(expected(char("]"), 'Missing "]"'))
            ]),
            ([, leading, expr, trailing]) => [
              {
                ...expr,
                leadingComments: [...expr.leadingComments, ...leading],
                trailingComments: [...expr.trailingComments, ...trailing]
              },
              true
            ]
          )
        ])
      )
    ]),
    ([obj, props]) => {
      if (props.length === 0) {
        return obj;
      }
      return props.slice(1).reduce((acc, [expr, computed]) => createMemberExpression(acc, expr, computed), createMemberExpression(obj, props[0][0], props[0][1]));
    }
  )(state);
}
const leftHandSideExpression = choice([
  attempt(callExpression),
  memberExpression
]);
const incrementOperator = string("++");
const decrementOperator = string("--");
const updateExpression = (state) => {
  const r = choice([
    attempt(
      map(
        concat([
          choice([incrementOperator, decrementOperator]),
          cut(
            expected(
              leftHandSideExpression,
              "Missing left-hand side expression"
            )
          )
        ]),
        ([op, arg]) => createUpdateExpression(arg, op, true)
      )
    ),
    map(
      concat([
        leftHandSideExpression,
        option(choice([incrementOperator, decrementOperator]))
      ]),
      ([arg, op]) => op.state === "some" ? createUpdateExpression(arg, op.value, false) : arg
    )
  ])(state);
  if (r.type === "success" && r.data.type === "UpdateExpression") {
    const valid = function check(node) {
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
          return true;
        case "ParenthesizedExpression":
          switch (node.expression.type) {
            case "Identifier":
            case "MemberExpression":
            case "ParenthesizedExpression":
              return check(node.expression);
            default:
              return false;
          }
        default:
          return false;
      }
    }(r.data.argument);
    if (!valid) {
      return error("failure", true, {
        ...r.state,
        errors: r.state.errors.append({
          message: "Invalid left-hand side expression in prefix operation",
          range: [state.offset, r.state.offset - 1]
        })
      });
    }
  }
  return r;
};
const unaryExpressionOperator = choice([
  char("+"),
  char("-"),
  char("~"),
  char("!")
]);
const unaryExpression = (state) => {
  return choice([
    updateExpression,
    map(
      many1(
        concat([
          preceded(peek(not(tagClose)), unaryExpressionOperator),
          choice([updateExpression, unaryExpression])
        ])
      ),
      ([[op, arg]]) => createUnaryExpression(op, arg)
    )
  ])(state);
};
const operator = (op) => preceded(not(peek(tagClose)), op.length === 1 ? char(op) : string(op));
const binaryExpression = (expr, operators, factory) => map(
  concat([
    expr,
    option(
      preceded(
        peek(concat([whitespaceOrComment, operators])),
        concat([
          whitespaceOrComment,
          many(
            map(
              concat([
                operators,
                whitespaceOrComment,
                cut(expected(expr, "Missing right operand")),
                whitespaceOrComment
              ]),
              ([op, leading, operand, trailing]) => [
                op,
                {
                  ...operand,
                  leadingComments: [...operand.leadingComments, ...leading],
                  trailingComments: [
                    ...operand.trailingComments,
                    ...trailing
                  ]
                }
              ]
            )
          )
        ])
      )
    )
  ]),
  ([left, opt]) => {
    if (opt.state === "none") {
      return left;
    }
    const [trailing, rest] = opt.value;
    return rest.reduce(
      (acc, [op, right]) => factory(acc, op, right),
      { ...left, trailingComments: [...left.trailingComments, ...trailing] }
    );
  }
);
const multiplicativeExpression = binaryExpression(
  unaryExpression,
  choice([operator("*"), operator("/"), operator("%")]),
  createBinaryExpression
);
const additiveExpression = binaryExpression(
  multiplicativeExpression,
  choice([operator("+"), operator("-")]),
  createBinaryExpression
);
const relationalExpression = binaryExpression(
  additiveExpression,
  choice([
    attempt(operator("<=")),
    attempt(operator(">=")),
    operator("<"),
    operator(">")
  ]),
  createBinaryExpression
);
const equalityExpression = binaryExpression(
  relationalExpression,
  choice([operator("=="), operator("!=")]),
  createBinaryExpression
);
const logicalANDExpression = binaryExpression(equalityExpression, operator("&&"), createLogicalExpression);
const logicalORExpression = binaryExpression(
  logicalANDExpression,
  attempt(operator("||")),
  // May be pipe delimiter
  createLogicalExpression
);
const conditionalExpression = (state) => {
  return map(
    concat([
      logicalORExpression,
      option(
        preceded(
          peek(concat([whitespaceOrComment, char("?")])),
          cut(
            concat([
              whitespaceOrComment,
              char("?"),
              map(
                concat([
                  whitespaceOrComment,
                  expected(conditionalExpression, "Missing expression"),
                  whitespaceOrComment
                ]),
                ([leading, cond, trailing]) => ({
                  ...cond,
                  leadingComments: [...cond.leadingComments, ...leading],
                  trailingComments: [...cond.trailingComments, ...trailing]
                })
              ),
              expected(char(":"), '":" expected after expression'),
              map(
                concat([
                  whitespaceOrComment,
                  expected(
                    conditionalExpression,
                    'Missing expression after ":"'
                  )
                ]),
                ([leading, cond]) => ({
                  ...cond,
                  leadingComments: [...cond.leadingComments, ...leading]
                })
              )
            ])
          )
        )
      )
    ]),
    ([test, opt]) => {
      if (opt.state === "none") {
        return test;
      }
      const [trailing, , consequent, , alternate] = opt.value;
      return createConditionalExpression(
        {
          ...test,
          trailingComments: [...test.trailingComments, ...trailing]
        },
        consequent,
        alternate
      );
    }
  )(state);
};
const argumentList = list(
  map(
    concat([whitespaceOrComment, conditionalExpression, whitespaceOrComment]),
    ([leading, expr, trailing]) => ({
      ...expr,
      leadingComments: [...expr.leadingComments, ...leading],
      trailingComments: [...expr.trailingComments, ...trailing]
    })
  ),
  char(",")
);
const parseArguments = map(
  concat([
    char("("),
    choice([
      attempt(
        map(argumentList, (args) => ({
          args,
          comments: []
        }))
      ),
      map(whitespaceOrComment, (comments) => ({
        args: [],
        comments
      }))
    ]),
    cut(expected(char(")"), 'Missing ")" after function call'))
  ]),
  ([, { args, comments }], range) => ({
    args,
    range,
    comments
  })
);
const callExpressionCallee = map(
  concat([memberExpression, many1(parseArguments)]),
  ([callee, [first, ...rest]]) => {
    return rest.reduce(
      (acc, cur) => createCallExpression(acc, cur.args, false, [
        acc.range[0],
        cur.range[1]
      ]),
      createCallExpression(
        callee,
        first.args,
        false,
        [callee.range[0], first.range[1]],
        [],
        first.comments
      )
    );
  }
);
function callExpression(state) {
  return map(
    concat([
      callExpressionCallee,
      many(
        choice([
          attempt(
            map(
              preceded(
                char("."),
                cut(expected(staticMemberAccessor, "Missing member property"))
              ),
              (p) => [p, false]
            )
          ),
          map(
            concat([
              char("["),
              whitespaceOrComment,
              cut(expected(expression, 'Missing expression after "["')),
              whitespaceOrComment,
              cut(expected(char("]"), 'Missing "]"'))
            ]),
            ([, leading, expr, trailing]) => [
              {
                ...expr,
                leadingComments: [...expr.leadingComments, ...leading],
                trailingComments: [...expr.trailingComments, ...trailing]
              },
              true
            ]
          )
        ])
      )
    ]),
    ([callee, props]) => {
      if (props.length === 0) {
        return callee;
      }
      return props.slice(1).reduce(
        (acc, [expr, computed]) => createMemberExpression(acc, expr, computed),
        createMemberExpression(callee, props[0][0], props[0][1])
      );
    }
  )(state);
}
const pipeArgumentList = (state) => many(preceded(whitespace1, unaryExpression))(state);
const pipeHeadCallee = choice([
  attempt(conditionalExpression),
  leftHandSideExpression
]);
const pipeHead = map(
  concat([pipeHeadCallee, pipeArgumentList]),
  ([callee, args], range) => args.length < 1 ? callee : createCallExpression(callee, args, true, range)
);
const pipeBody = map(
  concat([memberExpression, pipeArgumentList]),
  ([callee, args], range) => args.length < 1 ? callee : createCallExpression(callee, args, true, range)
);
const pipeExpression = map(
  concat([
    map(concat([pipeHead, whitespaceOrComment]), ([head, trailing]) => ({
      ...head,
      trailingComments: [...head.trailingComments, ...trailing]
    })),
    many(
      map(
        concat([
          char("|"),
          whitespaceOrComment,
          expected(pipeBody, "Missing argument after pipe delimiter"),
          whitespaceOrComment
        ]),
        ([, leading, body, trailing]) => ({
          ...body,
          leadingComments: [...body.leadingComments, ...leading],
          trailingComments: [...body.trailingComments, ...trailing]
        })
      )
    )
  ]),
  ([head, rest]) => {
    if (rest.length === 0) {
      return head;
    }
    return rest.reduce((acc, cur) => {
      if (cur.type === "CallExpression") {
        return {
          ...cur,
          args: [acc, ...cur.args],
          range: [acc.range[0], cur.range[1]]
        };
      } else {
        return createCallExpression(cur, [acc], true, [
          acc.range[0],
          cur.range[1]
        ]);
      }
    }, head);
  }
);
function parenthesizedExpression(state) {
  return map(
    concat([
      char("("),
      whitespaceOrComment,
      expression,
      whitespaceOrComment,
      cut(expected(char(")"), 'Missing ")" after expression'))
    ]),
    ([, leading, expr, trailing], r) => createParenthesizedExpression(expr, r, leading, trailing)
  )(state);
}
function expression(state) {
  return pipeExpression(state);
}

const endStatement = map(
  string("end"),
  (_, r) => createEndStatement(r)
);
const continueStatement = map(
  string("continue"),
  (_, r) => createContinueStatement(r)
);
const breakStatement = map(
  string("break"),
  (_, r) => createBreakStatement(r)
);
const variableStatement = map(
  concat([
    identifier,
    whitespaceOrComment,
    string(":="),
    whitespaceOrComment,
    cut(expected(expression, 'Missing expression after ":="'))
  ]),
  ([left, trailing, , leading, right]) => createVariableStatement(
    {
      ...left,
      trailingComments: [...left.trailingComments, ...trailing]
    },
    {
      ...right,
      leadingComments: [...right.leadingComments, ...leading]
    }
  )
);
const ifStatement = (state) => {
  const $head = map(
    concat([
      string("if"),
      whitespaceOrComment,
      cut(expected(expression, 'Missing expression after "if" keyword')),
      whitespaceOrComment,
      cut(expected(tagClose, `Missing "${state.tags[1]}"`))
    ]),
    ([, leading, expr, trailing, close]) => [
      {
        ...expr,
        leadingComments: [...expr.leadingComments, ...leading],
        trailingComments: [...expr.trailingComments, ...trailing]
      },
      close
    ]
  );
  const $end = map(
    concat([tagOpen, whitespaceOrComment, endStatement]),
    ([open, trailing]) => ({
      ...open,
      trailingComments: [...open.trailingComments, ...trailing]
    })
  );
  const $else = map(
    concat([tagOpen, whitespaceOrComment, string("else")]),
    ([open, leading]) => ({
      ...open,
      leadingComments: [...open.leadingComments, ...leading]
    })
  );
  return choice([
    // if <expr> }}<template>?{{ end
    attempt(
      map(
        concat([$head, manyTill(templateBody, $end)]),
        ([[test, ifClose], [consequent, endOpen]], range) => createIfStatement(
          test,
          consequent,
          null,
          {
            ifClose,
            endOpen,
            elseOpen: null,
            elseClose: null
          },
          range
        )
      )
    ),
    // if <expr> }}<template>?{{ else }}<template>?{{ end
    attempt(
      map(
        concat([
          $head,
          manyTill(templateBody, $else),
          whitespaceOrComment,
          tagClose,
          manyTill(templateBody, $end)
        ]),
        ([
          [test, ifClose],
          [consequent, elseOpen],
          leading,
          elseClose,
          [alternate, endOpen]
        ], range) => createIfStatement(
          test,
          consequent,
          alternate,
          {
            ifClose,
            elseOpen,
            elseClose: {
              ...elseClose,
              leadingComments: [...elseClose.leadingComments, ...leading]
            },
            endOpen
          },
          range
        )
      )
    ),
    // if <expr> }}<template>?{{ else <ifstatement>
    map(
      concat([
        $head,
        manyTill(templateBody, $else),
        whitespaceOrComment,
        ifStatement
      ]),
      ([[test, ifClose], [consequent, elseOpen], leading, alternate], range) => createIfStatement(
        test,
        consequent,
        {
          ...alternate,
          leadingComments: [...alternate.leadingComments, ...leading]
        },
        {
          ifClose,
          elseOpen,
          elseClose: null,
          endOpen: null
        },
        range
      )
    )
  ])(state);
};
const forBinding = map(
  concat([
    map(concat([identifier, whitespaceOrComment]), ([ident, trailing]) => ({
      ...ident,
      trailingComments: [...ident.trailingComments, ...trailing]
    })),
    option(
      map(
        preceded(char(","), concat([whitespaceOrComment, identifier])),
        ([leading, ident]) => ({
          ...ident,
          leadingComments: [...ident.leadingComments, ...leading]
        })
      )
    )
  ]),
  ([v, k]) => [v, k]
);
const forStatement = (state) => map(
  concat([
    string("for"),
    whitespace1,
    whitespaceOrComment,
    cut(expected(forBinding, 'Missing expression after "for" keyword')),
    whitespaceOrComment,
    cut(expected(string("in"), '"in" expected after expression')),
    whitespaceOrComment,
    cut(expected(expression, "Missing expression after for ~ in")),
    whitespaceOrComment,
    cut(expected(tagClose, `Missing "${state.tags[1]}"`)),
    cut(
      label(
        manyTill(
          templateBody,
          concat([tagOpen, whitespaceOrComment, endStatement])
        ),
        `Missing "${state.tags[0]} end ${state.tags[1]}" after for statement`
      )
    )
  ]),
  ([
    ,
    ,
    leading1,
    [value, index],
    trailing1,
    ,
    leading2,
    right,
    trailing2,
    close,
    [body, [open, trailing3]]
  ], range) => {
    return createForStatement(
      {
        ...value,
        leadingComments: [...value.leadingComments, ...leading1],
        trailingComments: index.state === "some" ? value.trailingComments : [...value.trailingComments, ...trailing1]
      },
      index.state === "some" ? {
        ...index.value,
        trailingComments: [...index.value.trailingComments, ...trailing1]
      } : null,
      {
        ...right,
        leadingComments: [...right.leadingComments, ...leading2],
        trailingComments: [...right.trailingComments, ...trailing2]
      },
      body,
      {
        close,
        open: {
          ...open,
          trailingComments: [...open.trailingComments, ...trailing3]
        }
      },
      range
    );
  }
)(state);
const expressionStatement = map(
  expression,
  (expr) => createExpressionStatement(expr)
);
const statement = choice([
  attempt(variableStatement),
  attempt(ifStatement),
  attempt(forStatement),
  attempt(continueStatement),
  attempt(breakStatement),
  expressionStatement
]);
const tagTemplate = (state) => map(
  concat([
    tagOpen,
    whitespaceOrComment,
    option(statement),
    whitespaceOrComment,
    expected(tagClose, `Missing "${state.tags[1]}"`)
  ]),
  ([open, leading, stmt, trailing, close]) => createTagTemplate(
    open,
    stmt.state === "some" ? stmt.value : null,
    close,
    leading,
    trailing
  )
)(state);
const rawTemplate = map(
  many1(diff(any, attempt(tagOpen))),
  (body, r) => createRawTemplate(body.join(""), r)
);
function templateBody(state) {
  return choice([attempt(rawTemplate), tagTemplate])(state);
}
function template(state) {
  return many(templateBody)(state);
}

const program = (state) => {
  return map(
    concat([template, eof]),
    ([body]) => createProgram(body, state.input.join(""))
  )(state);
};
const parse = (source, options) => {
  const result = program({
    input: [...source],
    rest: [],
    offset: 0,
    errors: ParseErrorStack.from([]),
    tags: options?.tags ?? defaults.tags
  });
  if (result.type === "error") {
    const err = result.state.errors.latest();
    const msg = err?.message ?? "Unexpected end of input";
    const range = err?.range ?? [result.state.offset, result.state.offset];
    throw error$1(`SyntaxError: ${msg}`, {
      source,
      range
    });
  }
  return result.data;
};

const render = (source, context) => {
  const ast = parse(source, { tags: context.tags });
  return compile(ast, context);
};

export { compile, createBinaryExpression, createBooleanLiteral, createBreakStatement, createCallExpression, createComment, createConditionalExpression, createContext, createContinueStatement, createEndStatement, createExpressionStatement, createForStatement, createHelper, createIdentifier, createIfStatement, createLogicalExpression, createMemberExpression, createNullLiteral, createNumericLiteral, createParenthesizedExpression, createProgram, createRawTemplate, createStringLiteral, createTag, createTagTemplate, createUnaryExpression, createUndefinedLiteral, createUpdateExpression, createVariableStatement, defineHelper, extendContext, format, isBinaryExpression, isBooleanLiteral, isBreakStatement, isCallExpression, isComment, isConditionalExpression, isContinueStatement, isEndStatement, isExpression, isExpressionStatement, isForStatement, isIdentifier, isIfStatement, isLeftHandSideExpression, isLiteral, isLogicalExpression, isMemberExpression, isNullLiteral, isNumericLiteral, isParenthesizedExpression, isPrimaryExpression, isProgram, isRawTemplate, isStringLiteral, isTag, isTagTemplate, isUnaryExpression, isUndefinedLiteral, isUpdateExpression, isVariableStatement, parse, render };
