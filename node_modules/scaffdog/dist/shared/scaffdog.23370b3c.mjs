import path, { dirname, resolve } from 'path';
import { loadConfig } from '@scaffdog/config';
import { defineHelper, render, extendContext, createContext, compile, createHelper } from '@scaffdog/engine';
import vm from 'vm';
import isPlainObject from 'is-plain-obj';
import { extract } from '@scaffdog/core';
import { ScaffdogAggregateError, ScaffdogError } from '@scaffdog/error';
import frontmatter from 'front-matter';
import * as z from 'zod';
import { z as z$1 } from 'zod';
import chalk from 'chalk';
import indentString from 'indent-string';
import { readFileSync, statSync } from 'fs';
import { mkdir, readFile, writeFile } from 'fs/promises';
import { globby } from 'globby';
import Fuse from 'fuse.js';
import inquirer from 'inquirer';
import inquirerAutocompletePrompt from 'inquirer-autocomplete-prompt';

const createFsLibrary = () => {
  const fstat = (filepath) => {
    try {
      return statSync(filepath);
    } catch (e) {
      return null;
    }
  };
  return {
    mkdir: async (filepath, options) => {
      await mkdir(filepath, options);
    },
    readFile: async (filepath) => {
      return await readFile(filepath, "utf8");
    },
    readFileSync: (filepath) => {
      return readFileSync(filepath, "utf8");
    },
    glob: async (patterns, options) => {
      return await globby(patterns, options);
    },
    writeFile: async (filepath, data) => {
      return await writeFile(filepath, data, "utf8");
    },
    fileExists: (filepath) => {
      return fstat(filepath)?.isFile() ?? false;
    },
    directoryExists: (filepath) => {
      return fstat(filepath)?.isDirectory() ?? false;
    }
  };
};

const fs = createFsLibrary();
const isObjectVariable = (input) => {
  return input != null && isPlainObject(input);
};
const helpers = /* @__PURE__ */ new Map();
defineHelper(helpers, "eval", (ctx, v, code) => {
  const evalCode = code != null ? code : v;
  const context = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of ctx.variables.entries()) {
    context[key] = value;
  }
  return vm.runInNewContext(evalCode, context);
});
defineHelper(
  helpers,
  "resolve",
  (_, ...args) => path.resolve(...args),
  {
    disableAutoLoop: true
  }
);
defineHelper(
  helpers,
  "relative",
  (ctx, to) => {
    const output = ctx.variables.get("output");
    const document = ctx.variables.get("document");
    if (!isObjectVariable(output) || !isObjectVariable(document)) {
      return "";
    }
    if (typeof output.abs !== "string" || typeof document.path !== "string") {
      return "";
    }
    return path.relative(
      path.dirname(output.abs),
      path.join(path.dirname(document.path), to)
    );
  },
  {
    disableAutoLoop: true
  }
);
defineHelper(
  helpers,
  "read",
  (ctx, target) => {
    const document = ctx.variables.get("document");
    if (!isObjectVariable(document) || typeof document.path !== "string") {
      throw new Error('"document" is invalid variable.');
    }
    const filepath = path.resolve(path.dirname(document.path), target);
    if (!fs.fileExists(filepath)) {
      throw new Error(`"${filepath}" does not exists.`);
    }
    const content = fs.readFileSync(filepath);
    return render(
      content,
      extendContext(ctx, {
        variables: /* @__PURE__ */ new Map([
          [
            "document",
            {
              ...document,
              path: filepath
            }
          ]
        ])
      })
    );
  },
  {
    disableAutoLoop: true
  }
);

const assignGlobalVariables = (context, { cwd, document }) => {
  context.variables.set("cwd", cwd);
  context.variables.set("document", {
    name: document.name,
    dir: path.dirname(document.path),
    path: document.path
  });
};
const createTemplateVariables = ({
  cwd,
  dir,
  name
}) => {
  const absolute = path.resolve(dir, name);
  const relative = path.relative(cwd, absolute);
  const info = path.parse(relative);
  const variables = /* @__PURE__ */ new Map([
    [
      "output",
      {
        root: info.dir,
        path: relative,
        abs: absolute,
        name: info.name,
        base: info.base,
        ext: info.ext,
        dir: info.dir
      }
    ]
  ]);
  return variables;
};

const createScaffdogInitializer = ({
  lib
}) => {
  const createScaffdog = ({
    filepath,
    config,
    cwd = process.cwd()
  }) => ({
    path: {
      project: dirname(filepath),
      config: filepath
    },
    config,
    list: async () => {
      return await lib.document.resolve(dirname(filepath), config.files, {
        tags: config.tags
      });
    },
    generate: async (document, output, options = {}) => {
      const context = createContext({
        cwd,
        variables: config.variables,
        helpers: new Map([...config.helpers, ...helpers]),
        tags: config.tags
      });
      assignGlobalVariables(context, {
        cwd,
        document
      });
      let inputs;
      if (typeof options.inputs === "function") {
        inputs = await options.inputs(context);
      } else {
        inputs = options.inputs ?? {};
      }
      context.variables.set("inputs", inputs);
      const files = [];
      for (const [key, ast] of document.variables) {
        context.variables.set(key, compile(ast, context));
      }
      for (const tpl of document.templates) {
        const filename = compile(tpl.filename, context);
        if (/^!/.test(filename)) {
          const name = filename.slice(1);
          files.push({
            skip: true,
            path: resolve(output, filename.slice(1)),
            name,
            content: ""
          });
          continue;
        }
        const ctx = extendContext(context, {
          variables: createTemplateVariables({
            cwd,
            dir: output,
            name: filename
          })
        });
        files.push({
          skip: false,
          path: resolve(output, filename),
          name: filename,
          content: compile(tpl.content, ctx)
        });
      }
      return files;
    }
  });
  return {
    createScaffdog,
    loadScaffdog: async (path, options) => {
      const result = loadConfig(path);
      return createScaffdog({
        ...result,
        cwd: options?.cwd
      });
    }
  };
};

const createConfigLibrary = (logger, error) => ({
  load: (project) => {
    try {
      const result = loadConfig(project);
      logger.debug("loaded config path: %s", result.filepath);
      logger.debug("loaded config: %O", result.config);
      return result;
    } catch (e) {
      error.handle(e, "Load Config Error");
      return null;
    }
  }
});

const questionIfSchema = z.union([z.boolean(), z.string()]);
const rawQuestionCheckboxSchema = z.object({
  message: z.string(),
  choices: z.array(z.string()),
  multiple: z.boolean().optional(),
  initial: z.array(z.string()).optional(),
  if: questionIfSchema.optional()
}).strict();
const rawQuestionListSchema = z.object({
  message: z.string(),
  choices: z.array(z.string()),
  multiple: z.boolean().optional(),
  initial: z.string().optional(),
  if: questionIfSchema.optional()
}).strict();
const rawQuestionConfirmSchema = z.object({
  confirm: z.string(),
  initial: z.boolean().optional(),
  if: questionIfSchema.optional()
}).strict();
const rawQuestionInputSchema = z.object({
  message: z.string(),
  initial: z.string().optional(),
  if: questionIfSchema.optional()
}).strict();
const rawQuestionObjectSchema = z.union([
  rawQuestionCheckboxSchema,
  rawQuestionListSchema,
  rawQuestionConfirmSchema,
  rawQuestionInputSchema
]);
const rawQuestionSchema = z.union([
  z.string(),
  // input syntax sugar
  rawQuestionObjectSchema
]);
const rawQuestionRecordSchema = z.record(z.string(), rawQuestionSchema);
const isQuestionObject = (v) => isPlainObject(v);
const isQuestionCheckbox = (v) => isQuestionObject(v) && "choices" in v && v.multiple === true;
const isQuestionList = (v) => isQuestionObject(v) && "choices" in v && v.multiple !== true;
const isQuestionConfirm = (v) => isQuestionObject(v) && "confirm" in v;
const questionIf = createHelper((_, result) => {
  if (typeof result === "boolean") {
    return result ? "true" : "false";
  }
  throw new Error(
    'evaluation value of "questions.*.if" must be a boolean value'
  );
});
const confirmIf = (question, context) => {
  if (question.if != null) {
    if (typeof question.if === "boolean") {
      return question.if;
    }
    const fn = "__internal_question_if__";
    const ctx = extendContext(context, {
      helpers: /* @__PURE__ */ new Map([[fn, questionIf]])
    });
    return render(`{{ ${fn}(${question.if}) }}`, ctx) === "true";
  }
  return true;
};
const transformPromptQuestion = (question) => {
  const validate = (v) => v !== "" ? true : "required input!";
  switch (question.type) {
    case "confirm":
      return {
        type: "confirm",
        message: question.message,
        default: question.initial,
        validate
      };
    case "checkbox":
    case "list":
      return {
        type: question.type === "checkbox" ? "checkbox" : "list",
        message: question.message,
        choices: question.choices,
        default: question.initial,
        validate
      };
    default:
      return {
        type: "input",
        message: question.message,
        default: question.initial,
        validate
      };
  }
};
const getInitialValue = (question) => {
  switch (question.type) {
    case "confirm":
      return question.initial ?? false;
    case "checkbox":
    case "list":
      return question.type === "checkbox" ? question.initial ?? [] : question.initial ?? "";
    default:
      return question.initial ?? "";
  }
};
const parseAnswers = (questions, answers) => {
  const map = /* @__PURE__ */ new Map();
  for (const token of answers) {
    const index = token.indexOf(":");
    const key = token.slice(0, index).trim();
    const value = token.slice(index + 1);
    if (!questions.has(key)) {
      throw new Error(`"${key}" question is not defined`);
    }
    const question = questions.get(key);
    switch (question.type) {
      case "checkbox": {
        if (!question.choices.includes(value)) {
          const expected = question.choices.join(", ");
          throw new Error(`"${key}" must be the value of "${expected}"`);
        }
        const previous = map.get(key);
        map.set(key, previous == null ? [value] : [...previous, value]);
        break;
      }
      case "list": {
        if (!question.choices.includes(value)) {
          const expected = question.choices.join(", ");
          throw new Error(`"${key}" must be one of "${expected}"`);
        }
        map.set(key, value);
        break;
      }
      case "confirm": {
        if (value !== "true" && value !== "false") {
          throw new Error(
            `"${key}" must be true or false, but found "${value}"`
          );
        }
        map.set(key, value === "true");
        break;
      }
      default: {
        if (value === "") {
          throw new Error(`"${key}" is required but found empty value`);
        }
        map.set(key, value);
      }
    }
  }
  return map;
};
const createQuestionLibrary = (prompt) => ({
  parse: (questions) => {
    const map = /* @__PURE__ */ new Map();
    Object.entries(questions).forEach(([key, value]) => {
      const raw = typeof value === "string" ? {
        message: value
      } : value;
      if (isQuestionCheckbox(raw)) {
        const { multiple, ...rest } = raw;
        map.set(key, {
          ...rest,
          type: "checkbox"
        });
      } else if (isQuestionList(raw)) {
        const { multiple, ...rest } = raw;
        map.set(key, {
          ...rest,
          type: "list"
        });
      } else if (isQuestionConfirm(raw)) {
        const { confirm, ...rest } = raw;
        map.set(key, {
          ...rest,
          type: "confirm",
          message: confirm
        });
      } else {
        map.set(key, {
          ...raw,
          type: "input"
        });
      }
    });
    return map;
  },
  resolve: async ({ context, questions, answers }) => {
    const inputs = /* @__PURE__ */ Object.create(null);
    if (questions.size === 0) {
      return inputs;
    }
    const answer = parseAnswers(questions, answers);
    for (const [name, question] of questions) {
      const ctx = extendContext(context, {
        variables: /* @__PURE__ */ new Map([["inputs", inputs]])
      });
      if (answer.has(name)) {
        inputs[name] = answer.get(name);
      } else if (confirmIf(question, ctx)) {
        inputs[name] = await prompt.prompt(
          transformPromptQuestion(question)
        );
      } else {
        inputs[name] = getInitialValue(question);
      }
    }
    return inputs;
  }
});

const MARKDOWN_EXTNAME = /* @__PURE__ */ new Set([
  ".markdown",
  ".md",
  ".mdown",
  ".mdtext",
  ".mdtxt",
  ".mdwn",
  ".mkd",
  ".mkdn"
]);
const rawAttrSchema = z.object({
  name: z.string(),
  root: z.string(),
  output: z.union([z.string(), z.array(z.string())]),
  ignore: z.array(z.string()).optional(),
  questions: rawQuestionRecordSchema.optional()
});
const parse = (question, path2, input, options) => {
  const { attributes, body } = frontmatter(input);
  const attrs = rawAttrSchema.safeParse(attributes);
  if (!attrs.success) {
    const [issue] = attrs.error.issues;
    const paths = issue.path.join(".");
    const msg = `Document Parsing Error: in "${paths}": ${issue.message} at "${path2}"`;
    throw new ScaffdogError(msg, {
      source: input
    });
  }
  const questions = question.parse(attrs.data.questions ?? {});
  const { variables, templates } = extract(body, options);
  return {
    ...attrs.data,
    path: path2,
    variables,
    templates,
    questions
  };
};
const createDocumentLibrary = (fs, question) => ({
  resolve: async (dirname, patterns, options) => {
    const paths = await fs.glob(patterns, {
      cwd: dirname,
      onlyFiles: true,
      unique: true,
      dot: true,
      absolute: true
    });
    const results = await Promise.allSettled(
      paths.filter((filepath) => MARKDOWN_EXTNAME.has(path.extname(filepath))).map(async (filepath) => {
        const content = await fs.readFile(filepath);
        return parse(question, filepath, content, options);
      })
    );
    const [documents, errors] = results.reduce(
      (acc, cur) => {
        if (cur.status === "fulfilled") {
          acc[0].push(cur.value);
        } else {
          acc[1].push(cur.reason);
        }
        return acc;
      },
      [[], []]
    );
    if (errors.length > 0) {
      throw new ScaffdogAggregateError(
        errors,
        `${errors.length} documents failed to load`
      );
    }
    return documents;
  }
});

const indent = (s) => indentString(s, 4);
const format = (e) => {
  if (e instanceof ScaffdogError) {
    return indent(e.format({ color: true }));
  } else if (e instanceof z$1.ZodError) {
    const msg = [`${e.errors.length} issues found`];
    for (const err of e.errors) {
      const code = err.code.toUpperCase();
      const path = err.path.join(".");
      msg.push(`- ${code}: ${err.message} (in "${path}")`);
    }
    return indent(msg.join("\n"));
  }
  throw new TypeError("Invalid error type");
};
const createErrorLibrary = (logger) => ({
  handle: (e, title) => {
    if (e instanceof ScaffdogAggregateError) {
      logger.error(title, e.message);
      for (const err of e.errors) {
        if (err instanceof ScaffdogError) {
          logger.log(format(err));
        } else if (err instanceof z$1.ZodError) {
          logger.log(format(err));
        } else {
          logger.log(indent(chalk.red(e.message)));
        }
        logger.log("");
      }
    } else if (e instanceof ScaffdogError || e instanceof z$1.ZodError) {
      logger.error(title);
      logger.log(format(e));
    } else if (e instanceof Error) {
      e.message = `${title}: ${e.message}`;
      logger.error(e);
    } else {
      logger.error(title, e);
    }
    logger.log("");
    return 1;
  }
});

inquirer.registerPrompt("autocomplete", inquirerAutocompletePrompt);
const createPromptLibrary = () => {
  const prompt = async (question) => {
    const { value } = await inquirer.prompt([
      {
        ...question,
        name: "value"
      }
    ]);
    if (question.when === false && question.default != null) {
      return question.default;
    }
    return value;
  };
  return {
    prompt,
    confirm: async (message, initial, args) => {
      return await prompt({
        ...args,
        type: "confirm",
        default: initial,
        message
      });
    },
    autocomplete: async (message, list, args) => {
      const fuse = new Fuse(list, {});
      return await prompt({
        ...args,
        type: "autocomplete",
        message,
        pageSize: 20,
        source: (_, input) => {
          return !input ? list : fuse.search(input || "").map(({ item }) => item);
        }
      });
    }
  };
};

const createLibrary = (logger) => {
  const fs = createFsLibrary();
  const error = createErrorLibrary(logger);
  const prompt = createPromptLibrary();
  const config = createConfigLibrary(logger, error);
  const question = createQuestionLibrary(prompt);
  const document = createDocumentLibrary(fs, question);
  return {
    fs,
    error,
    prompt,
    config,
    question,
    document
  };
};

export { createScaffdogInitializer as a, createLibrary as c };
