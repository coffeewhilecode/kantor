#!/usr/bin/env node
import { createRequire } from 'module';
import { LogLevels, createConsola } from 'consola';
import updateNotifier from 'update-notifier';
import { c as createLibrary, a as createScaffdogInitializer } from './shared/scaffdog.23370b3c.mjs';
import termSize from 'terminal-size';
import yargs from 'yargs';
import path from 'path';
import chalk, { Chalk } from 'chalk';
import { emojify } from 'node-emoji';
import validFilename from 'valid-filename';
import ansiEscapes from 'ansi-escapes';
import { isDynamicPattern } from 'globby';
import symbols from 'log-symbols';
import micromatch from 'micromatch';
import plur from 'plur';
import truncate from 'cli-truncate';
import figures from 'figures';
import wrap from 'wrap-ansi';
import stripAnsi from 'strip-ansi';
import { extract } from '@scaffdog/core';
import { createContext, compile } from '@scaffdog/engine';
import '@scaffdog/config';
import 'vm';
import 'is-plain-obj';
import '@scaffdog/error';
import 'front-matter';
import 'zod';
import 'indent-string';
import 'fs';
import 'fs/promises';
import 'fuse.js';
import 'inquirer';
import 'inquirer-autocomplete-prompt';

const buildCommandSignature = (name, args) => {
  const arr = [name];
  Object.entries(args).forEach(([key, opts]) => {
    const inner = opts.array ? `${key}..` : key;
    arr.push(opts.demandOption ? `<${inner}>` : `[${inner}]`);
  });
  return arr.join(" ");
};
const buildCommand = (yargs, module) => {
  return yargs.command(
    buildCommandSignature(module.name, module.args),
    "",
    module.build
  );
};
const createCommand = (definition) => {
  return (run) => {
    return {
      ...definition,
      build: (yargs) => {
        yargs.options(definition.flags);
        Object.entries(definition.args).forEach(([key, opts]) => {
          yargs.positional(key, opts);
        });
        if (definition.commands != null) {
          definition.commands.forEach((module) => {
            buildCommand(yargs, module);
          });
        }
        return yargs;
      },
      run
    };
  };
};

const globalFlags = {
  project: {
    type: "string",
    alias: "p",
    description: "Directory to load the scaffdog project.",
    default: ".scaffdog",
    global: true
  },
  verbose: {
    type: "boolean",
    alias: "v",
    description: "Enable logging.",
    global: true
  },
  help: {
    type: "boolean",
    description: "Show help.",
    global: true
  },
  version: {
    type: "boolean",
    description: "Output the version number.",
    global: true
  }
};

const createCLI = ({
  pkg,
  logger,
  container,
  lib,
  api
}) => ({
  run: async (argv) => {
    const parser = yargs().help(false).version(false).detectLocale(false).parserConfiguration({
      "set-placeholder-key": true,
      "boolean-negation": false
    }).fail((msg, err) => {
      throw err != null ? err : new Error(msg);
    }).options(globalFlags).strict().exitProcess(false);
    container.all().forEach((module) => {
      buildCommand(parser, module);
    });
    const parsed = await (async () => {
      try {
        return await parser.parse(argv);
      } catch (e) {
        logger.error(e);
        return null;
      }
    })();
    if (parsed == null) {
      return 1;
    }
    const { _, $0, ...rest } = parsed;
    const context = {
      cwd: process.cwd(),
      pkg,
      logger,
      container,
      lib,
      api,
      size: Object.defineProperties(
        {
          rows: 0,
          columns: 0
        },
        {
          rows: {
            enumerable: true,
            get: () => termSize().rows
          },
          columns: {
            enumerable: true,
            get: () => termSize().columns
          }
        }
      )
    };
    logger.debug("parsed arguments: %O", parsed);
    if (parsed.verbose) {
      logger.level = LogLevels.verbose;
    }
    if (parsed.version) {
      return await container.mustGet("version").run({
        ...context,
        args: {},
        flags: rest
      });
    }
    if (parsed.help || _.length === 0) {
      return await container.mustGet("help").run({
        ...context,
        args: {
          command: _
        },
        flags: rest
      });
    }
    const command = _.join(".") || "help";
    logger.debug(`command "${command}"`);
    logger.debug("running command...");
    try {
      const cmd = container.mustGet(command);
      const key = {
        args: new Set(Object.keys(cmd.args)),
        flags: new Set(Object.keys(cmd.flags))
      };
      const { args, flags } = Object.entries(rest).reduce(
        (acc, [k, v]) => {
          if (key.args.has(k)) {
            acc.args[k] = v;
          } else if (key.flags.has(k)) {
            acc.flags[k] = v;
          }
          return acc;
        },
        {
          args: {},
          flags: {}
        }
      );
      return await cmd.run({
        ...context,
        args,
        flags: {
          ...rest,
          ...flags
        }
      });
    } catch (e) {
      logger.error(e);
      return 1;
    }
  }
});

const createCommandContainer = (commands) => {
  const map = /* @__PURE__ */ new Map();
  commands.forEach((mod) => {
    map.set(mod.name, mod);
    if (mod.commands != null) {
      mod.commands.forEach((child) => {
        map.set(`${mod.name}.${child.name}`, child);
      });
    }
  });
  return {
    all: () => {
      return Array.from(map.values());
    },
    main: () => {
      const results = [];
      map.forEach((module, key) => {
        if (!key.includes(".")) {
          results.push(module);
        }
      });
      return results;
    },
    get: (name) => {
      return map.get(name) ?? null;
    },
    mustGet: (name) => {
      const mod = map.get(name);
      if (mod == null) {
        throw new ReferenceError(`"${name}" command does not exists`);
      }
      return mod;
    }
  };
};

const create = createCommand({
  name: "create",
  summary: "Create a document file with the specified name.",
  args: {
    name: {
      type: "string",
      description: "Template document file name."
    }
  },
  flags: {
    yes: {
      type: "boolean",
      alias: "y",
      description: "Use default options."
    }
  }
})(async ({ cwd, logger, lib: { fs, prompt }, args, flags }) => {
  const { project } = flags;
  const dirname = path.resolve(cwd, project);
  if (!fs.directoryExists(dirname)) {
    logger.error(
      `"${project}" does not exists. Please use \`$ scaffdog init\` to setup the scaffdog project.`
    );
    return 1;
  }
  let name;
  if (args.name) {
    if (!validFilename(args.name)) {
      logger.error("Should be a valid filename!");
      return 1;
    }
    name = args.name;
  } else {
    name = await prompt.prompt({
      type: "input",
      message: "Please enter a filename.",
      validate: (v) => {
        if (v === "") {
          return "required input!";
        }
        if (!validFilename(v)) {
          return "should be a valid fliename!";
        }
        return true;
      },
      filter: (v) => v.trim()
    });
  }
  const filepath = path.resolve(cwd, project, `${name}.md`);
  if (fs.fileExists(filepath)) {
    logger.error(`"${path.join(cwd, filepath)}" already exists.`);
    return 1;
  }
  const attrs = [`name: '${name}'`];
  const dirs = await fs.glob(".", {
    cwd,
    onlyDirectories: true,
    dot: true,
    unique: true,
    gitignore: true
  });
  dirs.unshift(".");
  const root = await prompt.autocomplete(
    "Please select a root directory.",
    dirs,
    {
      default: ".",
      when: !flags.yes
    }
  );
  attrs.push(`root: '${root}'`);
  const output = await prompt.prompt({
    type: "input",
    message: "Please enter a output pattern.",
    default: "**/*",
    when: !flags.yes
  });
  attrs.push(`output: '${output}'`);
  attrs.push("ignore: []");
  const questions = [`value: 'Please enter any text.'`].map((line) => `  ${line}`).join("\n");
  attrs.push(`questions:
${questions}`);
  await fs.writeFile(
    filepath,
    `
---
${attrs.join("\n")}
---

# \`{{ inputs.value }}.md\`

\`\`\`markdown
Let's make a document!
See scaffdog documentation for details.
https://scaff.dog/docs/templates
\`\`\`
`.trim()
  );
  logger.log("");
  logger.log(
    emojify(
      `:dog: Created document ${chalk.bold(path.relative(cwd, filepath))}`
    )
  );
  return 0;
});

const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
const chars = {
  t: "\u252C",
  c: "\u253C",
  b: "\u2534",
  x: "\u2500",
  y: "\u2502"
};
const formatFile = (file, { columns, color }) => {
  const chk = new Chalk({
    level: color ? 1 : 0
  });
  const output = [];
  const lines = file.content.split(NEWLINE);
  const gutter = Math.max(`${lines.length}`.length + 2, 3);
  const body = chars.x.repeat(columns - gutter - 1);
  const filename = file.skip ? `(skip) ${file.name}` : file.name;
  output.push(
    chk.gray([chars.x.repeat(gutter), chars.t, body].join("")),
    [
      " ".repeat(gutter - 2),
      chk.green(figures.tick),
      " ",
      chk.gray(chars.y),
      ` File: ${chk.bold(truncate(filename, columns - gutter - 8))}`
    ].join(""),
    chk.gray([chars.x.repeat(gutter), chars.c, body].join(""))
  );
  let n = 1;
  lines.forEach((line) => {
    wrap(line, columns - gutter - 2, {
      trim: false,
      hard: true,
      wordWrap: false
    }).split(NEWLINE).forEach((l, i) => {
      const ns = `${n}`;
      const prefix = chk.gray((i === 0 ? ns : " ").padStart(gutter - 2));
      const lc = lines.length === 1 && line == "" ? "(empty)" : l;
      output.push(` ${prefix} ${chk.gray(chars.y)} ${lc}`);
    });
    n++;
  });
  return output.join("\n");
};

class InputsResolverError extends Error {
  constructor(parent) {
    super();
    this.parent = parent;
  }
}
const generate = createCommand({
  name: "generate",
  summary: "Build a scaffold using the specified template. If you do not specify the template name and execute it, interactively select the template.",
  args: {
    name: {
      type: "string",
      description: "Template document name."
    }
  },
  flags: {
    output: {
      type: "string",
      alias: "o",
      description: "Output destination directory. (Relative path from the `root` option)"
    },
    answer: {
      type: "string",
      alias: "a",
      array: true,
      description: 'Answer to question. The answer value is the key/value separated by ":" and can be specified multiple times.'
    },
    "dry-run": {
      type: "boolean",
      alias: "n",
      description: "Output the result to stdout."
    },
    force: {
      type: "boolean",
      alias: "f",
      default: false,
      description: "Attempt to write the files without prompting for confirmation."
    }
  }
})(async ({
  cwd,
  logger,
  lib: { fs, error, prompt, config, question },
  api,
  size,
  args,
  flags
}) => {
  const { project } = flags;
  const dirname = path.resolve(cwd, project);
  const cfg = config.load(dirname);
  if (cfg == null) {
    return 1;
  }
  const scaffdog = api({
    ...cfg,
    cwd
  });
  if (!flags.verbose) {
    logger.log(ansiEscapes.clearScreen);
  }
  let documents;
  try {
    documents = await scaffdog.list();
  } catch (e) {
    return error.handle(e, "Document Resolve Error");
  }
  if (documents.length === 0) {
    logger.error(
      "Document file not found. Please use `$ scaffdog create <name>` to create the document file."
    );
    return 1;
  }
  const name = args.name ?? await prompt.prompt({
    type: "list",
    message: "Please select a document.",
    choices: documents.map((d) => d.name)
  });
  logger.debug("using name: %s", name);
  const doc = documents.find((d) => d.name === name);
  if (doc == null) {
    logger.error(`Document "${name}" not found.`);
    return 1;
  }
  logger.debug("found document: %O", doc);
  let dirs = await (async () => {
    if (flags.output != null) {
      return [path.join(doc.root, flags.output)];
    }
    const directories = /* @__PURE__ */ new Set([doc.root]);
    const output = typeof doc.output === "string" ? [doc.output] : doc.output;
    for (const pattern of output) {
      if (isDynamicPattern(pattern)) {
        const found = await fs.glob(path.join(doc.root, pattern), {
          cwd,
          onlyDirectories: true,
          dot: true,
          unique: true,
          gitignore: true
        });
        found.forEach((dir) => {
          directories.add(dir);
        });
      } else {
        directories.add(path.join(doc.root, pattern));
      }
    }
    return Array.from(directories);
  })();
  logger.debug("found directories: %O", dirs);
  if (doc.ignore != null && doc.ignore.length > 0) {
    dirs = micromatch.not(dirs, doc.ignore);
    logger.debug("filtered directories: %O", dirs);
  }
  let dist;
  if (dirs.length > 1) {
    dist = await prompt.autocomplete(
      "Please select the output destination directory.",
      dirs,
      {}
    );
  } else {
    dist = dirs[0];
    logger.info(`Output destination directory: "${chalk.bold.green(dist)}"`);
  }
  logger.debug("selected dist: %s", dist);
  dist = path.resolve(cwd, dist);
  logger.debug("normalized dist: %s", dist);
  let files;
  try {
    files = await scaffdog.generate(doc, dist, {
      inputs: async (context) => {
        try {
          const inputs = await question.resolve({
            context,
            questions: doc.questions ?? {},
            answers: flags.answer ?? []
          });
          logger.debug(
            "variables: %O",
            new Map([...context.variables, ["inputs", inputs]])
          );
          return inputs;
        } catch (e) {
          throw new InputsResolverError(e);
        }
      }
    });
  } catch (e) {
    if (e instanceof InputsResolverError) {
      return error.handle(e.parent, "Question Error");
    } else {
      return error.handle(e, "Compile Error");
    }
  }
  logger.debug("files: %O", files);
  const writes = /* @__PURE__ */ new Set();
  const skips = /* @__PURE__ */ new Set();
  if (flags["dry-run"]) {
    files.forEach((file) => {
      if (!file.skip) {
        logger.log("");
        logger.log(
          formatFile(file, {
            columns: size.columns,
            color: true
          })
        );
      }
      if (file.skip) {
        skips.add(file);
      } else {
        writes.add(file);
      }
    });
  } else {
    for (const file of files) {
      if (file.skip) {
        skips.add(file);
        continue;
      }
      await fs.mkdir(path.dirname(file.path), { recursive: true });
      if (!flags.force && fs.fileExists(file.path)) {
        const relative = path.relative(cwd, file.path);
        const ok = await prompt.confirm(
          `Would you like to overwrite it? ("${chalk.bold.yellow(relative)}")`,
          false,
          {
            prefix: symbols.warning
          }
        );
        if (!ok) {
          skips.add(file);
          continue;
        }
      }
      await fs.writeFile(file.path, file.content);
      writes.add(file);
    }
  }
  const msg = {
    write: chalk.bold.green(`${writes.size} ${plur("file", writes.size)}`),
    skip: skips.size > 0 ? chalk.bold.gray(` (${skips.size} skipped)`) : ""
  };
  logger.log("");
  logger.log(emojify(`:dog: Generated ${msg.write}!${msg.skip}`));
  logger.log("");
  [...writes, ...skips].forEach((file) => {
    const skipped = skips.has(file);
    const prefix = " ".repeat(4);
    const relative = path.relative(cwd, file.path);
    const output = [
      prefix,
      skipped ? symbols.warning : symbols.success,
      skipped ? relative : chalk.bold(relative)
    ];
    if (skipped) {
      output.push(chalk.gray("(skipped)"));
    }
    logger.log(output.join(" "));
  });
  return 0;
});

const length = (s) => stripAnsi(s).length;
const buildUsage = (sections) => {
  const maxContentSize = sections.reduce((max, section) => {
    if (!Array.isArray(section.content)) {
      return max;
    }
    return section.content.reduce((acc, cur) => {
      return Math.max(acc, length(cur.name));
    }, max);
  }, 0);
  return sections.map((section) => {
    const wrapContent = (s) => section.raw === true ? s : `  ${s}`;
    const line = [];
    if (section.header != null) {
      line.push(chalk.bold(section.header));
    }
    if (typeof section.content === "string") {
      line.push(wrapContent(section.content));
    } else {
      section.content.forEach((content) => {
        const padding = " ".repeat(maxContentSize - length(content.name));
        line.push(
          wrapContent(`${content.name}${padding}  ${content.summary}`)
        );
      });
    }
    return line.join("\n");
  }).join("\n\n");
};

const buildFlagName = (name, opts) => {
  if (opts.alias != null) {
    const aliases = typeof opts.alias === "string" ? [opts.alias] : opts.alias;
    const alias = aliases.map((s) => `-${s}`).join(", ");
    return `${alias}, --${name}`;
  }
  return `    --${name}`;
};
const globalFlagsContent = {
  header: "GLOBAL FLAGS",
  content: Object.entries(globalFlags).map(([name, opts]) => ({
    name: buildFlagName(name, opts),
    summary: opts.description
  }))
};
const help = createCommand({
  name: "help",
  summary: "Show help.",
  args: {
    command: {
      type: "string",
      array: true
    }
  },
  flags: {}
})(async ({ pkg, logger, container, args }) => {
  const command = args.command ?? [];
  const name = command.join(".");
  if (name !== "") {
    const module = container.get(name);
    if (module == null) {
      logger.error(`"${name}" command does not exists`);
      return 1;
    }
    let usage = `scaffdog ${command.join(" ")}`;
    if (module.commands != null) {
      usage += " <command>";
    }
    const args2 = Object.entries(module.args);
    if (args2.length > 0) {
      const multiple = args2.length > 1;
      const overview = args2.map(([arg, opts]) => {
        return opts.array === true ? `<${arg}..>` : `<${arg}>`;
      }).join(" | ");
      usage += ` ${multiple ? "{" : ""}${overview}${multiple ? "}" : ""}`;
    }
    if (Object.keys(module.flags).length > 0) {
      usage += " [flags]";
    }
    const availableCommands = module.commands != null ? module.commands.map((cmd) => ({
      name: cmd.name,
      summary: cmd.summary
    })) : [];
    const cmdFlags = Object.entries(module.flags).map(([key, opts]) => ({
      name: buildFlagName(key, opts),
      summary: opts.description
    }));
    logger.log(
      buildUsage([
        {
          content: module.summary,
          raw: true
        },
        {
          header: "USAGE",
          content: usage
        },
        ...availableCommands.length > 0 ? [
          {
            header: "AVAILABLE COMMANDS",
            content: availableCommands
          }
        ] : [],
        ...cmdFlags.length > 0 ? [
          {
            header: "COMMAND FLAGS",
            content: cmdFlags
          }
        ] : [],
        globalFlagsContent
      ])
    );
    return 0;
  }
  const main = container.main();
  logger.log(
    buildUsage([
      {
        content: pkg.description,
        raw: true
      },
      {
        header: "USAGE",
        content: [
          "scaffdog",
          "<command>",
          main.length > 0 ? "[subcommand..]" : "",
          "[flags]"
        ].filter(Boolean).join(" ")
      },
      ...main.length > 0 ? [
        {
          header: "AVAILABLE COMMANDS",
          content: main.map((module) => ({
            name: module.name,
            summary: module.summary
          }))
        }
      ] : [],
      globalFlagsContent,
      {
        content: chalk.gray(
          // prettier-ignore
          `Run ${chalk.bold("scaffdog help [command..]")} for help with a specific command.`
        ),
        raw: true
      }
    ])
  );
  return 0;
});

const init = createCommand({
  name: "init",
  summary: "Prepare to use scaffdog. Create a `.scaffdog` directory by default, and create a first document file.",
  args: {},
  flags: {}
})(async ({ cwd, logger, lib: { fs, prompt }, flags }) => {
  const { project } = flags;
  const dirname = path.resolve(cwd, project);
  if (fs.directoryExists(dirname)) {
    const ok = await prompt.confirm(
      // prettier-ignore
      `"${chalk.bold.yellow(project)}" already exist. Do you want to continue the setup?`,
      false,
      {}
    );
    if (!ok) {
      logger.warn("Setup canceled!");
      return 1;
    }
  }
  await fs.mkdir(dirname, { recursive: true });
  const { templates } = extract(
    `
# \`config.js\`

\`\`\`javascript
export default {
  files: ['*'],
};
\`\`\`

# \`{{ name }}.md\`

\`\`\`\`markdown
---
name: '{{ name }}'
root: '.'
output: '**/*'
ignore: []
questions:
  value: 'Please enter any text.'
---

# \`{{ placeholder }}.md\`

\`\`\`markdown
Let's make a document!
See scaffdog documentation for details.
https://scaff.dog/docs/templates
\`\`\`
\`\`\`\`
`.trim(),
    {}
  );
  const name = await prompt.prompt({
    type: "input",
    message: "Please enter a document name.",
    validate: (v) => v !== "" ? true : "required input!"
  });
  const context = createContext({});
  context.variables.set("name", name);
  context.variables.set("placeholder", `{{ inputs.value }}`);
  const files = await Promise.all(
    templates.map(async (tpl) => {
      const name2 = compile(tpl.filename, context);
      const file = {
        skip: false,
        path: path.resolve(dirname, name2),
        name: name2,
        content: compile(tpl.content, context)
      };
      await fs.writeFile(file.path, file.content);
      return file;
    })
  );
  const list = files.map((file) => {
    const relative = path.relative(cwd, file.path);
    return `  ${symbols.success} ${chalk.bold(relative)}`;
  }).join("\n");
  logger.log("");
  logger.log(
    emojify(
      `
Setup of ${chalk.bold.green("scaffdog")} :dog: is complete!

${list}

Now you can do scaffold by running ${chalk.bold.green("$ scaffdog generate")}.

Please refer to the following documents and customize it.
${chalk.underline("https://scaff.dog/docs/templates")}
      `.trim()
    )
  );
  return 0;
});

const count = (word, cnt) => `${cnt} ${plur(word, cnt)}`;
const list = createCommand({
  name: "list",
  summary: "Print a list of available documents.",
  args: {},
  flags: {}
})(async ({ cwd, logger, lib: { config }, api, flags }) => {
  const { project } = flags;
  const dirname = path.resolve(cwd, project);
  const cfg = config.load(dirname);
  if (cfg == null) {
    return 1;
  }
  const scaffdog = api({
    ...cfg,
    cwd
  });
  const documents = await scaffdog.list();
  if (documents.length === 0) {
    logger.warn("Document file not found.");
    return 1;
  }
  documents.forEach((doc) => {
    const relative = path.relative(cwd, doc.path);
    const t = count("template", doc.templates.length);
    const q = count("question", doc.questions.size);
    const meta = [relative, t, q].join(", ");
    logger.log(`- ${chalk.bold(doc.name)} ${chalk.gray(`(${meta})`)}`);
  });
  const total = documents.length;
  logger.log("");
  logger.log(`${chalk.bold.green(total)} ${plur("file", total)} found.`);
  return 0;
});

const version = createCommand({
  name: "version",
  summary: "Output the version number.",
  args: {},
  flags: {}
})(async ({ pkg, logger }) => {
  logger.log(`v${pkg.version}`);
  return 0;
});

const commands = [create, generate, help, init, list, version];

const require = createRequire(import.meta.url);
(async () => {
  const logger = createConsola({
    level: LogLevels.info,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    fancy: true,
    formatOptions: {
      date: false
    }
  });
  process.on("uncaughtException", (e) => {
    logger.error(e);
    process.exit(1);
  });
  process.on("unhandledRejection", (e) => {
    logger.error(e);
    process.exit(1);
  });
  try {
    const pkg = require("../package.json");
    updateNotifier({
      pkg,
      distTag: pkg.version?.includes("canary") ? "canary" : "latest"
    }).notify();
    const container = createCommandContainer(commands);
    const lib = createLibrary(logger);
    const { createScaffdog: api } = createScaffdogInitializer({
      lib
    });
    const cli = createCLI({
      pkg,
      logger,
      container,
      lib,
      api
    });
    const code = await cli.run(process.argv.slice(2));
    logger.log("");
    process.exit(code);
  } catch (e) {
    logger.error(e);
    process.exit(1);
  }
})();
